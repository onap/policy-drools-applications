/*
 * ============LICENSE_START=======================================================
 * ONAP
 * ================================================================================
 * Copyright (C) 2018-2019 AT&T Intellectual Property. All rights reserved.
 * ================================================================================
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ============LICENSE_END=========================================================
 */

package org.onap.policy.controlloop;

import org.onap.policy.controlloop.params.ControlLoopParams;
import org.onap.policy.controlloop.VirtualControlLoopEvent;
import org.onap.policy.controlloop.VirtualControlLoopNotification;
import org.onap.policy.controlloop.ControlLoopEventStatus;
import org.onap.policy.controlloop.ControlLoopNotificationType;
import org.onap.policy.controlloop.ControlLoopLogger;
import org.onap.policy.controlloop.policy.PolicyResult;
import org.onap.policy.controlloop.policy.ControlLoopPolicy;
import org.onap.policy.controlloop.policy.Policy;
import org.onap.policy.controlloop.eventmanager.ControlLoopEventManager;
import org.onap.policy.controlloop.eventmanager.ControlLoopEventManager.NEW_EVENT_STATUS;
import org.onap.policy.controlloop.eventmanager.ControlLoopOperationManager;
import org.onap.policy.controlloop.actor.so.SoActorServiceProvider;
import org.onap.policy.aai.AaiNqResponseWrapper;
import org.onap.policy.appc.Request;
import org.onap.policy.appc.Response;
import org.onap.policy.appc.CommonHeader;
import org.onap.policy.appclcm.LcmRequestWrapper;
import org.onap.policy.appclcm.LcmResponseWrapper;
import org.onap.policy.appclcm.LcmRequest;
import org.onap.policy.appclcm.LcmResponse;
import org.onap.policy.appclcm.LcmCommonHeader;
import org.onap.policy.sdnr.PciRequestWrapper;
import org.onap.policy.sdnr.PciResponseWrapper;
import org.onap.policy.sdnr.PciRequest;
import org.onap.policy.sdnr.PciResponse;
import org.onap.policy.vfc.VfcRequest;
import org.onap.policy.vfc.VfcResponse;
import org.onap.policy.vfc.VfcManager;
import org.onap.policy.so.SOManager;
import org.onap.policy.so.SORequest;
import org.onap.policy.so.SORequestStatus;
import org.onap.policy.so.SORequestDetails;
import org.onap.policy.so.SOModelInfo;
import org.onap.policy.so.SOCloudConfiguration;
import org.onap.policy.so.SORequestInfo;
import org.onap.policy.so.SORequestParameters;
import org.onap.policy.so.SORelatedInstanceListElement;
import org.onap.policy.so.SORelatedInstance;
import org.onap.policy.so.SOResponse;
import org.onap.policy.so.SOResponseWrapper;
import org.onap.policy.sdnc.SdncRequest;
import org.onap.policy.sdnc.SdncManager;
import org.onap.policy.sdnc.SdncResponse;
import org.onap.policy.guard.PolicyGuard;
import org.onap.policy.guard.PolicyGuard.LockResult;
import org.onap.policy.guard.TargetLock;
import org.onap.policy.guard.GuardResult;
import org.onap.policy.guard.PolicyGuardRequest;
import org.onap.policy.guard.PolicyGuardResponse;
import org.onap.policy.guard.PolicyGuardXacmlRequestAttributes;
import org.onap.policy.guard.PolicyGuardXacmlHelper;

import org.yaml.snakeyaml.Yaml;
import org.yaml.snakeyaml.constructor.Constructor;

import org.slf4j.LoggerFactory;
import org.slf4j.Logger;

import java.time.Instant;
import java.util.LinkedList;
import java.util.Iterator;

import org.onap.policy.drools.system.PolicyEngine;

/*
 * This object is to provide support for timeouts
 * due to a bug in drools' built-in timers
 */
declare ControlLoopTimer
    closedLoopControlName : String
    requestID : String
    delay : String
    expired : boolean
    //timerType is the type of timer: either "ClosedLoop" or "Operation"
    timerType : String
end

/*
*
* Called when the ControlLoopParams object has been inserted into working memory from the BRMSGW.
*
*/
rule "INSERT.PARAMS"
    when
        $params : ControlLoopParams()
    then

    // Note: globals have bad behavior when persistence is used,
    //       hence explicitly getting the logger vs using a global

    Logger logger = LoggerFactory.getLogger(drools.getRule().getPackage());
    logger.info("{}: {} : YAML=[{}]", $params.getClosedLoopControlName(), $params.getPolicyName() + "." 
        + drools.getRule().getName(), $params.getControlLoopYaml());
end

/*
*
* This rule responds to DCAE Events where there is no manager yet. Either it is
* the first ONSET, or a subsequent badly formed Event (i.e. Syntax error, or is-closed-loop-disabled)
*
*/
rule "EVENT"
    when
        $params : ControlLoopParams( $clName : getClosedLoopControlName() )
        $event : VirtualControlLoopEvent( closedLoopControlName == $clName )
        not ( ControlLoopEventManager( closedLoopControlName == $event.getClosedLoopControlName(), 
            requestID == $event.getRequestId() ) )
    then

    Logger logger = LoggerFactory.getLogger(drools.getRule().getPackage());
    logger.info("{}: {}", $clName, $params.getPolicyName() + "." + drools.getRule().getName());

    try {

        //
        // Check the event, because we need it to not be null when
        // we create the ControlLoopEventManager. The ControlLoopEventManager
        // will do extra syntax checking as well check if the closed loop is disabled.
        //
        if ($event.getRequestId() == null) {
            VirtualControlLoopNotification notification = new VirtualControlLoopNotification($event);
            notification.setNotification(ControlLoopNotificationType.REJECTED);
            notification.setFrom("policy");
            notification.setMessage("Missing requestID");
            notification.setPolicyName($params.getPolicyName() + "." + drools.getRule().getName());
            notification.setPolicyScope($params.getPolicyScope());
            notification.setPolicyVersion($params.getPolicyVersion());

            //
            // Let interested parties know
            //
            PolicyEngine.manager.deliver("POLICY-CL-MGT", notification);

            //
            // Retract it from memory
            //
            retract($event);
        } else if ($event.getClosedLoopEventStatus() != ControlLoopEventStatus.ONSET) {
            throw new ControlLoopException($event.getClosedLoopEventStatus() + " received with no prior onset");
        } else {
            //
            // Create an EventManager
            //
            ControlLoopEventManager manager = new ControlLoopEventManager($clName, $event.getRequestId());
            //
            // Determine if EventManager can actively process the event 
            // (i.e. syntax, is_closed_loop_disabled checks etc.)
            //
            VirtualControlLoopNotification notification = manager.activate($params.getControlLoopYaml(), $event);
            notification.setFrom("pdp-0001-controller=controlloop"); // Engine.getInstanceName()
            notification.setPolicyName($params.getPolicyName() + "." + drools.getRule().getName());
            notification.setPolicyScope($params.getPolicyScope());
            notification.setPolicyVersion($params.getPolicyVersion());
            //
            // Are we actively pursuing this event?
            //
            if (notification.getNotification() == ControlLoopNotificationType.ACTIVE) {
                //
                // Insert Event Manager into memory, this will now kick off processing.
                //
                insert(manager);
                //
                // Let interested parties know
                //
                PolicyEngine.manager.deliver("POLICY-CL-MGT", notification);
                //
                // Setup the Overall Control Loop timer
                //
                ControlLoopTimer clTimer = new ControlLoopTimer();
                clTimer.setTimerType("ClosedLoop");
                clTimer.setClosedLoopControlName($event.getClosedLoopControlName());
                clTimer.setRequestID($event.getRequestId().toString());
                clTimer.setDelay(manager.getControlLoopTimeout(1500) + "s");
                //
                // Insert it
                //
                insert(clTimer);
            } else {
                //
                // Let interested parties know
                //
                PolicyEngine.manager.deliver("POLICY-CL-MGT", notification);
                //
                // Retract it from memory
                //
                retract($event);
            }

            //
            // Now that the manager is inserted into Drools working memory, we'll wait for
            // another rule to fire in order to continue processing. This way we can also
            // then screen for additional ONSET and ABATED events for this RequestID.
            //
        }
    } catch (Exception e) {
        logger.warn("{}: {}", $clName, $params.getPolicyName() + "." + drools.getRule().getName(), e);

        VirtualControlLoopNotification notification = new VirtualControlLoopNotification($event);
        notification.setNotification(ControlLoopNotificationType.REJECTED);
        notification.setMessage("Exception occurred: " + e.getMessage());
        notification.setPolicyName($params.getPolicyName() + "." + drools.getRule().getName());
        notification.setPolicyScope($params.getPolicyScope());
        notification.setPolicyVersion($params.getPolicyVersion());
        //
        //
        //
        PolicyEngine.manager.deliver("POLICY-CL-MGT", notification);
        //
        // Retract the event
        //
        retract($event);
    }
end

/*
*
* This rule happens when we got a valid ONSET, closed loop is enabled and an Event Manager
* is now created. We can start processing the yaml specification via the Event Manager.
*
*/
rule "EVENT.MANAGER"
    when
        $params : ControlLoopParams( $clName : getClosedLoopControlName() )
        $event : VirtualControlLoopEvent( closedLoopControlName == $clName )
        $manager : ControlLoopEventManager( closedLoopControlName == $event.getClosedLoopControlName(), 
            requestID == $event.getRequestId() )
        $clTimer : ControlLoopTimer( closedLoopControlName == $event.getClosedLoopControlName(), 
            requestID == $event.getRequestId().toString(), timerType == "ClosedLoop", !expired )
    then

    Logger logger = LoggerFactory.getLogger(drools.getRule().getPackage());
    logger.info("{}: {}: event={} manager={} clTimer={}",
                $clName, $params.getPolicyName() + "." + drools.getRule().getName(),
                $event, $manager, $clTimer);

    try {
        //
        // Check which event this is.
        //
        ControlLoopEventManager.NEW_EVENT_STATUS eventStatus = $manager.onNewEvent($event);
        //
        // Check what kind of event this is
        //
        if (eventStatus == NEW_EVENT_STATUS.SUBSEQUENT_ONSET) {
            //
            // We don't care about subsequent onsets
            //
            logger.info("{}: {}: subsequent onset",
                        $clName, $params.getPolicyName() + "." + drools.getRule().getName());
            retract($event);
            return;
        }
        if (eventStatus == NEW_EVENT_STATUS.SYNTAX_ERROR) {
            //
            // Ignore any bad syntax events
            //
            logger.warn("{}: {}: syntax error",
                        $clName, $params.getPolicyName() + "." + drools.getRule().getName());
            retract($event);
            return;
        }
        //
        // We only want the initial ONSET event in memory,
        // all the other events need to be retracted to support
        // cleanup and avoid the other rules being fired for this event.
        //
        if (eventStatus != NEW_EVENT_STATUS.FIRST_ONSET) {
            logger.warn("{}: {}: no first onset",
                        $clName, $params.getPolicyName() + "." + drools.getRule().getName());
            retract($event);
        }

        logger.debug("{}: {}: target={}", $clName,
                     $params.getPolicyName() + "." + drools.getRule().getName(), $event.getTarget());
        //
        // Now start seeing if we need to process this event
        //

        //
        // Check if this is a Final Event
        //
        VirtualControlLoopNotification notification = $manager.isControlLoopFinal();


        if (notification != null) {
            //
            // Its final, but are we waiting for abatement?
            //
            if ($manager.getNumAbatements() > 0) {
                logger.info("{}: {}: abatement received for {}.  Closing the control loop",
                            $clName, $params.getPolicyName() + "." + drools.getRule().getName(),
                            $event.getRequestId());
                notification.setFrom("policy");
                notification.setPolicyName($params.getPolicyName() + "." + drools.getRule().getName());
                notification.setPolicyScope($params.getPolicyScope());
                notification.setPolicyVersion($params.getPolicyVersion());
                //
                // In this case, we are done
                //
                PolicyEngine.manager.deliver("POLICY-CL-MGT", notification);
                //
                // Unlock the target
                //
                TargetLock lock = $manager.unlockCurrentOperation();
                if (lock != null) {
                    logger.debug("{}: {}: retracting lock=", $clName,
                                 $params.getPolicyName() + "." + drools.getRule().getName(), lock);
                    retract(lock);
                }
                //
                // Retract everything from memory
                //
                logger.info("{}: {}: retracting onset, manager, and timer",
                            $clName, $params.getPolicyName() + "." + drools.getRule().getName());

                retract($manager.getOnsetEvent());
                
                // don't retract manager, etc. - a clean-up rule will do that
                
                //
                // TODO - what if we get subsequent Events for this RequestID?
                // By default, it will all start over again. May be confusing for Ruby.
                // Or, we could track this and then subsequently ignore the events
                //
            } else {
                //
                // Check whether we need to wait for abatement
                //
                if ($manager.getProcessor().getControlLoop().getAbatement() == true && notification.getNotification() == ControlLoopNotificationType.FINAL_SUCCESS) {
                  logger.info("{}: {}: waiting for abatement ..",
                              $clName, $params.getPolicyName() + "." + drools.getRule().getName());
                } else {
                  logger.info("{}: {}: no abatement expect for {}.  Closing the control loop",
                              $clName, $params.getPolicyName() + "." + drools.getRule().getName(),
                              $event.getRequestId());

                  notification.setFrom("policy");
                  notification.setPolicyName($params.getPolicyName() + "." + drools.getRule().getName());
                  notification.setPolicyScope($params.getPolicyScope());
                  notification.setPolicyVersion($params.getPolicyVersion());

                  //
                  // In this case, we are done
                  //
                  PolicyEngine.manager.deliver("POLICY-CL-MGT", notification);
                  //
                  // Unlock the target
                  //
                  TargetLock lock = $manager.unlockCurrentOperation();
                  if (lock != null) {
                      logger.debug("{}: {}: retracting lock=", $clName,
                                  $params.getPolicyName() + "." + drools.getRule().getName(), lock);
                      retract(lock);
                  }
                  //
                  // Retract everything from memory
                  //
                  logger.info("{}: {}: retracting onset, manager, and timer",
                              $clName, $params.getPolicyName() + "." + drools.getRule().getName());

                  retract($manager.getOnsetEvent());
                
                  // don't retract manager, etc. - a clean-up rule will do that
                }
            }
        } else {
            //
            // NOT final, so let's ask for the next operation
            //
            ControlLoopOperationManager operation = $manager.processControlLoop();
            if (operation != null) {
              //
              // Let's ask for a lock right away
              //
              LockResult<GuardResult, TargetLock> result = $manager.lockCurrentOperation();
              logger.info("{}: {}: guard lock acquired={}",
                            $clName, $params.getPolicyName() + "." + drools.getRule().getName(),
                            result.getB());
              if (result.getA().equals(GuardResult.LOCK_ACQUIRED)) {
                  //
                  // insert the operation into memory
                  //
                  insert(operation);

                  //
                  // insert operation timeout object
                  //
                  ControlLoopTimer opTimer = new ControlLoopTimer();
                  opTimer.setTimerType("Operation");
                  opTimer.setClosedLoopControlName($event.getClosedLoopControlName());
                  opTimer.setRequestID($event.getRequestId().toString());
                  opTimer.setDelay(operation.getOperationTimeout().toString() + "s");
                  insert(opTimer);

                  //
                  // Insert lock into memory
                  //
                  insert(result.getB());
              }
              else {
                  logger.debug("The target resource {} is already processing",
                                $event.getAai().get($event.getTarget()));
                  notification = new VirtualControlLoopNotification($event);
                  notification.setNotification(ControlLoopNotificationType.REJECTED);
                  notification.setMessage("The target " + $event.getAai().get($event.getTarget()) 
                      + " is already locked");
                  notification.setFrom("policy");
                  notification.setPolicyName($params.getPolicyName() + "." + drools.getRule().getName());
                  notification.setPolicyScope($params.getPolicyScope());
                  notification.setPolicyVersion($params.getPolicyVersion());

                  PolicyEngine.manager.deliver("POLICY-CL-MGT", notification);

                  retract($event);
                
                  // don't retract manager, etc. - a clean-up rule will do that

                if(result.getB() != null) {
                  retract(result.getB());
                }
              }
              logger.info("{}: {}: starting operation={}",
                          $clName, $params.getPolicyName() + "." + drools.getRule().getName(),
                          operation);
            } else {
              //
              // Probably waiting for abatement
              //
              logger.info("{}: {}: no operation, probably waiting for abatement",
                          $clName, $params.getPolicyName() + "." + drools.getRule().getName());
            }
        }
    } catch (Exception e) {
        logger.warn("{}: {}: unexpected",
                   $clName,
                   $params.getPolicyName() + "." + drools.getRule().getName(), e);

        VirtualControlLoopNotification notification = new VirtualControlLoopNotification($event);
        notification.setNotification(ControlLoopNotificationType.FINAL_FAILURE);
        notification.setMessage(e.getMessage());
        notification.setFrom("policy");
        notification.setPolicyName($params.getPolicyName() + "." + drools.getRule().getName());
        notification.setPolicyScope($params.getPolicyScope());
        notification.setPolicyVersion($params.getPolicyVersion());

        PolicyEngine.manager.deliver("POLICY-CL-MGT", notification);

        retract($event);
                
        // don't retract manager, etc. - a clean-up rule will do that
    }

end

/*
*
* Guard Permitted, let's send request to the actor.
*
*/
rule "EVENT.MANAGER.OPERATION.LOCKED.GUARD_PERMITTED"
    when
        $params : ControlLoopParams( $clName : getClosedLoopControlName() )
        $event : VirtualControlLoopEvent( closedLoopControlName == $clName )
        $manager : ControlLoopEventManager( closedLoopControlName == $event.getClosedLoopControlName(), 
            requestID == $event.getRequestId() )
        $operation : ControlLoopOperationManager( onset.closedLoopControlName == $event.getClosedLoopControlName(),
            onset.getRequestId() == $event.getRequestId(), "Permit".equalsIgnoreCase(getGuardApprovalStatus()) )
        $lock : TargetLock (requestID == $event.getRequestId())
        $opTimer : ControlLoopTimer( closedLoopControlName == $event.getClosedLoopControlName(), 
            requestID == $event.getRequestId().toString(), timerType == "Operation", !expired )
    then

    Logger logger = LoggerFactory.getLogger(drools.getRule().getPackage());
    logger.info("{}: {}: event={} manager={} operation={} lock={}",
                $clName, $params.getPolicyName() + "." + drools.getRule().getName(),
                $event, $manager, $operation, $lock);

    Object request = null;
    boolean caughtException = false;

    try {
        request = $operation.startOperation($event);

        if (request != null) {
          logger.debug("{}: {}: starting operation ..",
                       $clName,
                       $params.getPolicyName() + "." + drools.getRule().getName());
          //
          // Tell interested parties we are performing this Operation
          //
          VirtualControlLoopNotification notification = new VirtualControlLoopNotification($event);
          notification.setNotification(ControlLoopNotificationType.OPERATION);
          notification.setMessage($operation.getOperationMessage());
          notification.setHistory($operation.getHistory());
          notification.setFrom("policy");
          notification.setPolicyName($params.getPolicyName() + "." + drools.getRule().getName());
          notification.setPolicyScope($params.getPolicyScope());
          notification.setPolicyVersion($params.getPolicyVersion());

          PolicyEngine.manager.deliver("POLICY-CL-MGT", notification);

          switch ($operation.policy.getActor()){

              case "APPC":

                  if (request instanceof Request) {
                      PolicyEngine.manager.deliver("APPC-CL", request);
                  }
                  else if (request instanceof LcmRequestWrapper) {
                      PolicyEngine.manager.deliver("APPC-LCM-READ", request);
                  }
                  break;
              case "SO":
                  // at this point the AAI named query request should have already been made, the response 
                  // recieved and used in the construction of the SO Request which is stored in operationRequest

                  if(request instanceof SORequest) {
                      // Call SO. The response will be inserted into memory once it's received
                      SoActorServiceProvider.sendRequest($event.getRequestId().toString(), drools.getWorkingMemory(), request);
                  }
                  break;
              case "VFC":
                  if (request instanceof VfcRequest) {
                      // Start VFC thread
                      Thread t = new Thread(new VfcManager(drools.getWorkingMemory(), (VfcRequest)request));
                      t.start();
                  }
                  break;
              case "SDNR":
                  if (request instanceof PciRequestWrapper) {
                      PolicyEngine.manager.deliver("SDNR-CL", request);
                  }
                  break;
              
              case "SDNC":
                  if (request instanceof SdncRequest) {
                     // Start SDNC thread
                     Thread t = new Thread(new SdncManager(drools.getWorkingMemory(), (SdncRequest)request));
                     t.start();
                  }
                  break;                 
          }
        } else {
          //
          // What happens if its null?
          //
            logger.warn("{}: {}: unexpected null operation request",
                      $clName,
                      $params.getPolicyName() + "." + drools.getRule().getName());
            if ("SO".equals($operation.policy.getActor())) {
                retract($opTimer);
                retract($operation);
                modify($manager) {finishOperation($operation)};
            }
            else if ("vfc".equalsIgnoreCase($operation.policy.getActor())) {
                retract($opTimer);
                retract($operation);
                modify($manager) {finishOperation($operation)};
            }
            else if ("sdnc".equalsIgnoreCase($operation.policy.getActor())) {
                retract($opTimer);
                retract($operation);
                modify($manager) {finishOperation($operation)};
            }
        }

    } catch (Exception e) {
        String msg = e.getMessage();
        logger.warn("{}: {}: operation={}:  AAI failure: {}",
                    $clName,
                    $params.getPolicyName() + "." + drools.getRule().getName(),
                    $operation, msg, e);
        $operation.setOperationHasException(msg);

        if(request != null) {
            //
            // Create a notification for it ("DB Write - end operation")
            //
            VirtualControlLoopNotification notification = new VirtualControlLoopNotification($event);
            notification.setFrom("policy");
            notification.setPolicyName($params.getPolicyName() + "." + drools.getRule().getName());
            notification.setPolicyScope($params.getPolicyScope());
            notification.setPolicyVersion($params.getPolicyVersion());
            notification.setNotification(ControlLoopNotificationType.OPERATION_FAILURE);
            notification.setMessage($operation.getOperationHistory());
            notification.setHistory($operation.getHistory());

            PolicyEngine.manager.deliver("POLICY-CL-MGT", notification);
        }

        retract($opTimer);
        retract($operation);
        caughtException = true;
    }

    // Having the modify statement in the catch clause doesn't work for whatever reason
    if (caughtException) {
        modify($manager) {finishOperation($operation)};
    }
end


/*
*
* We were able to acquire a lock so now let's ask Xacml Guard whether
* we are allowed to proceed with the request to the actor.
*
*/
rule "EVENT.MANAGER.OPERATION.LOCKED.GUARD_NOT_YET_QUERIED"
    when
        $params : ControlLoopParams( $clName : getClosedLoopControlName() )
        $event : VirtualControlLoopEvent( closedLoopControlName == $clName )
        $manager : ControlLoopEventManager( closedLoopControlName == $event.getClosedLoopControlName(), 
            requestID == $event.getRequestId() )
        $operation : ControlLoopOperationManager( onset.closedLoopControlName == $event.getClosedLoopControlName(), 
            onset.getRequestId() == $event.getRequestId(), getGuardApprovalStatus() == "NONE" )
        $lock : TargetLock (requestID == $event.getRequestId())
    then

    Logger logger = LoggerFactory.getLogger(drools.getRule().getPackage());
    logger.info("{}: {}: event={} manager={} operation={} lock={}",
                $clName, $params.getPolicyName() + "." + drools.getRule().getName(),
                $event, $manager, $operation, $lock);

    //
    // Sending notification that we are about to query Guard ("DB write - start operation")
    //
    VirtualControlLoopNotification notification = new VirtualControlLoopNotification($event);
    notification.setNotification(ControlLoopNotificationType.OPERATION);
    notification.setMessage("Sending guard query for " + $operation.policy.getActor() + " " 
        + $operation.policy.getRecipe());
    notification.setHistory($operation.getHistory());
    notification.setFrom("policy");
    notification.setPolicyName($params.getPolicyName() + "." + drools.getRule().getName());
    notification.setPolicyScope($params.getPolicyScope());
    notification.setPolicyVersion($params.getPolicyVersion());

    PolicyEngine.manager.deliver("POLICY-CL-MGT", notification);

    //
    // Now send Guard Request to XACML Guard. In order to bypass the call to Guard,
    // just change guardEnabled to false.
    //
    // In order to use REST XACML, provide a URL instead of "" as a second argument
    // to the CallGuardTask() and set the first argument to null
    // (instead of XacmlPdpEngine).
    //

    // NOTE: The environment properties uses "guard.disabled" but the boolean is guardEnabled
    boolean guardEnabled = "false".equalsIgnoreCase(PolicyEngine.manager.getEnvironmentProperty("guard.disabled"));

    if(guardEnabled){

        Thread t = new Thread(new org.onap.policy.guard.CallGuardTask(
                                                        drools.getWorkingMemory(),
                                                        $event.getClosedLoopControlName(),
                                                        $operation.policy.getActor().toString(),
                                                        $operation.policy.getRecipe(),
                                                        $operation.getTargetEntity(),
                                                        $event.getRequestId().toString(),
                                                        () -> {
                                                            AaiNqResponseWrapper resp = $manager.getNqVserverFromAai();
                                                            return(resp == null ? null : resp.countVfModules());
                                                        }));
        t.start();
    }
    else{
        insert(new PolicyGuardResponse("Permit", $event.getRequestId(), $operation.policy.getRecipe()));
    }

end

//
// This rule will be triggered when a thread talking to the XACML Guard inserts a
// guardResponse object into the working memory
//
rule "GUARD.RESPONSE"
    when
        $params : ControlLoopParams( $clName : getClosedLoopControlName() )
        $event : VirtualControlLoopEvent( closedLoopControlName == $clName, 
            closedLoopEventStatus == ControlLoopEventStatus.ONSET )
        $manager : ControlLoopEventManager( closedLoopControlName == $event.getClosedLoopControlName(), 
            requestID == $event.getRequestId() )
        $operation : ControlLoopOperationManager( onset.closedLoopControlName == $event.getClosedLoopControlName(), 
            onset.getRequestId() == $event.getRequestId() )
        $lock : TargetLock (requestID == $event.getRequestId())
        $opTimer : ControlLoopTimer( closedLoopControlName == $event.getClosedLoopControlName(), 
            requestID == $event.getRequestId().toString(), timerType == "Operation", !expired )
        $guardResponse : PolicyGuardResponse(requestID == $event.getRequestId(), $operation.policy.recipe == operation)
    then

    Logger logger = LoggerFactory.getLogger(drools.getRule().getPackage());
    logger.info("{}: {}: event={} manager={} operation={} lock={} opTimer={} guardResponse={}",
                 $clName, $params.getPolicyName() + "." + drools.getRule().getName(),
                 $event, $manager, $operation, $lock, $opTimer, $guardResponse);


    //we will permit the operation if there was no Guard for it
    if("Indeterminate".equalsIgnoreCase($guardResponse.getResult())){
        $guardResponse.setResult("Permit");
    }

    //
    // This notification has Guard result in "message". ("DB write - end operation in case of Guard Deny")
    //
    VirtualControlLoopNotification notification = new VirtualControlLoopNotification($event);
    notification.setNotification(ControlLoopNotificationType.OPERATION);
    notification.setMessage("Guard result for " + $operation.policy.getActor() + " " + $operation.policy.getRecipe()
        + " is " + $guardResponse.getResult());
    notification.setHistory($operation.getHistory());
    notification.setFrom("policy");
    notification.setPolicyName($params.getPolicyName() + "." + drools.getRule().getName());
    notification.setPolicyScope($params.getPolicyScope());
    notification.setPolicyVersion($params.getPolicyVersion());

    PolicyEngine.manager.deliver("POLICY-CL-MGT", notification);

    if("Permit".equalsIgnoreCase($guardResponse.getResult())){

        modify($operation){setGuardApprovalStatus($guardResponse.getResult())};
    }
    else {
        //This is the Deny case
        $operation.startOperation($event);
        $operation.setOperationHasGuardDeny();
        retract($opTimer);
        retract($operation);
        modify($manager) {finishOperation($operation)};
    }

    retract($guardResponse);

end

/*
*
* This rule responds to APPC Response Events
*
* I would have like to be consistent and write the Response like this:
* $response : Response( CommonHeader.RequestId == $onset.getRequestId() )
*
* However, no compile error was given. But a runtime error was given. I think
* because drools is confused between the classname CommonHeader vs the property CommonHeader.
*
*/
rule "APPC.RESPONSE"
    when
        $params : ControlLoopParams( $clName : getClosedLoopControlName() )
        $event : VirtualControlLoopEvent( closedLoopControlName == $clName, 
            closedLoopEventStatus == ControlLoopEventStatus.ONSET )
        $manager : ControlLoopEventManager( closedLoopControlName == $event.getClosedLoopControlName(), 
            requestID == $event.getRequestId() )
        $operation : ControlLoopOperationManager( onset.closedLoopControlName == $event.getClosedLoopControlName(), 
            onset.getRequestId() == $event.getRequestId() )
        $opTimer : ControlLoopTimer( closedLoopControlName == $event.getClosedLoopControlName(), 
            requestID == $event.getRequestId().toString(), timerType == "Operation", !expired )
        $lock : TargetLock (requestID == $event.getRequestId())
        $response : Response( getCommonHeader().RequestId == $event.getRequestId() )
    then

    Logger logger = LoggerFactory.getLogger(drools.getRule().getPackage());
    logger.info("{}: {}", $clName, $params.getPolicyName() + "." + drools.getRule().getName());
    logger.debug("{}: {}: event={} manager={} operation={} lock={} opTimer={} response={}",
                 $clName, $params.getPolicyName() + "." + drools.getRule().getName(),
                 $event, $manager, $operation, $lock, $opTimer, $response);
    //
    // Get the result of the operation
    //
    PolicyResult policyResult = $operation.onResponse($response);
    if (policyResult != null) {
        logger.debug("{}: {}: operation finished - result={}",
                    $clName, $params.getPolicyName() + "." + drools.getRule().getName(),
                    policyResult);
        //
        // This Operation has completed, construct a notification showing our results. (DB write - end operation)
        //
        VirtualControlLoopNotification notification = new VirtualControlLoopNotification($event);
        notification.setFrom("policy");
        notification.setPolicyName($params.getPolicyName() + "." + drools.getRule().getName());
        notification.setPolicyScope($params.getPolicyScope());
        notification.setPolicyVersion($params.getPolicyVersion());
        notification.setMessage($operation.getOperationHistory());
        notification.setHistory($operation.getHistory());
        if (policyResult.equals(PolicyResult.SUCCESS)) {
            notification.setNotification(ControlLoopNotificationType.OPERATION_SUCCESS);
            //
            // Let interested parties know
            //
            PolicyEngine.manager.deliver("POLICY-CL-MGT", notification);
        } else {
            notification.setNotification(ControlLoopNotificationType.OPERATION_FAILURE);
            //
            // Let interested parties know
            //
            PolicyEngine.manager.deliver("POLICY-CL-MGT", notification);
        }
        //
        // Ensure the operation is complete
        //
        if ($operation.isOperationComplete() == true) {
            //
            // It is complete, remove it from memory
            //
            retract($operation);
            //
            // We must also retract the timer object
            // NOTE: We could write a Rule to do this
            //
            retract($opTimer);
            //
            // Complete the operation
            //
            modify($manager) {finishOperation($operation)};
        } else {
            //
            // Just doing this will kick off the LOCKED rule again
            //
            modify($operation) {};
        }
    } else {
        //
        // Its not finished yet (i.e. expecting more Response objects)
        //
        // Or possibly it is a leftover response that we timed the request out previously
        //
    }
    //
    // We are going to retract these objects from memory
    //
    retract($response);
end

/*
*
* The problem with Responses is that they don't have a controlLoopControlName
* field in them, so the only way to attach them is via RequestID. If we have multiple
* control loop .drl's loaded in the same container, we need to be sure the cleanup
* rules don't remove Responses for other control loops.
*
*/
rule "APPC.RESPONSE.CLEANUP"
    when
        $params : ControlLoopParams( $clName : getClosedLoopControlName() )
        $response : Response($id : getCommonHeader().RequestId )
        not ( VirtualControlLoopEvent( requestId == $id, closedLoopEventStatus == ControlLoopEventStatus.ONSET ) )
    then

    Logger logger = LoggerFactory.getLogger(drools.getRule().getPackage());
    logger.info("{}: {}", $clName, $params.getPolicyName() + "." + drools.getRule().getName());
    logger.debug("{}: {}: orphan appc response={}",
                $clName, $params.getPolicyName() + "." + drools.getRule().getName(), $id);

    //
    // Retract it
    //
    retract($response);
end

/*
*
* This rule responds to APPC Response Events using the new LCM interface provided by appc
*
*/
rule "APPC.LCM.RESPONSE"
    when
        $params : ControlLoopParams( $clName : getClosedLoopControlName() )
        $event : VirtualControlLoopEvent( closedLoopControlName == $clName, 
            closedLoopEventStatus == ControlLoopEventStatus.ONSET )
        $manager : ControlLoopEventManager( closedLoopControlName == $event.getClosedLoopControlName(), 
            requestID == $event.getRequestId() )
        $operation : ControlLoopOperationManager( onset.closedLoopControlName == $event.getClosedLoopControlName(), 
            onset.getRequestId() == $event.getRequestId() )
        $opTimer : ControlLoopTimer( closedLoopControlName == $event.getClosedLoopControlName(), 
            requestID == $event.getRequestId().toString(), timerType == "Operation", !expired )
        $lock : TargetLock (requestID == $event.getRequestId())
        $response : LcmResponseWrapper( getBody().getCommonHeader().getRequestId() == $event.getRequestId() )
    then

    Logger logger = LoggerFactory.getLogger(drools.getRule().getPackage());
    logger.info("{}: {}", $clName, $params.getPolicyName() + "." + drools.getRule().getName());
    logger.debug("{}: {}: event={} manager={} operation={} lock={} opTimer={} response={}",
                $clName, $params.getPolicyName() + "." + drools.getRule().getName(),
                $event, $manager, $operation, $lock, $operation, $opTimer, $response);

    //
    // Get the result of the operation
    //
    PolicyResult policyResult = $operation.onResponse($response);
    if (policyResult != null) {
      logger.debug("{}: {}: operation finished - result={}",
                  $clName, $params.getPolicyName() + "." + drools.getRule().getName(),
                  policyResult);

      //
      // This Operation has completed, construct a notification showing our results. (DB write - end operation)
      //
      VirtualControlLoopNotification notification = new VirtualControlLoopNotification($event);
      notification.setFrom("policy");
      notification.setPolicyName($params.getPolicyName() + "." + drools.getRule().getName());
      notification.setPolicyScope($params.getPolicyScope());
      notification.setPolicyVersion($params.getPolicyVersion());
      notification.setMessage($operation.getOperationHistory());
      notification.setHistory($operation.getHistory());
      if (policyResult.equals(PolicyResult.SUCCESS)) {
          notification.setNotification(ControlLoopNotificationType.OPERATION_SUCCESS);
      } else {
          notification.setNotification(ControlLoopNotificationType.OPERATION_FAILURE);
      }
      PolicyEngine.manager.deliver("POLICY-CL-MGT", notification);
      //
      // Ensure the operation is complete
      //
      if ($operation.isOperationComplete() == true) {
          //
          // It is complete, remove it from memory
          //
          retract($operation);
          //
          // We must also retract the timer object
          // NOTE: We could write a Rule to do this
          //
          retract($opTimer);
          //
          // Complete the operation
          //
          modify($manager) {finishOperation($operation)};
      } else {
          //
          // Just doing this will kick off the LOCKED rule again
          //
          modify($operation) {};
      }
    } else {
        //
        // Its not finished yet (i.e. expecting more Response objects)
        //
        // Or possibly it is a leftover response that we timed the request out previously
        //
    }
    //
    // We are going to retract these objects from memory
    //
    retract($response);
end

/*
*
* Clean Up any lingering LCM reponses
*
*/
rule "APPC.LCM.RESPONSE.CLEANUP"
    when
        $params : ControlLoopParams( $clName : getClosedLoopControlName() )
        $response : LcmResponseWrapper($id : getBody().getCommonHeader().getRequestId )
        not ( VirtualControlLoopEvent( requestId == $id, closedLoopEventStatus == ControlLoopEventStatus.ONSET ) )
    then

    Logger logger = LoggerFactory.getLogger(drools.getRule().getPackage());
    logger.info("{}: {}", $clName, $params.getPolicyName() + "." + drools.getRule().getName());
    logger.debug("{}: {}: orphan appc response={}",
                $clName, $params.getPolicyName() + "." + drools.getRule().getName(), $id);
    //
    // Retract it
    //
    retract($response);
end

/*
*
* This rule responds to SO Response Events
*
*/
rule "SO.RESPONSE"
    when
        $params : ControlLoopParams( $clName : getClosedLoopControlName() )
        $event : VirtualControlLoopEvent( closedLoopControlName == $clName, 
            closedLoopEventStatus == ControlLoopEventStatus.ONSET )
        $manager : ControlLoopEventManager( closedLoopControlName == $event.getClosedLoopControlName(), 
            requestID == $event.getRequestId() )
        $operation : ControlLoopOperationManager( onset.closedLoopControlName == $event.getClosedLoopControlName(), 
            onset.getRequestId() == $event.getRequestId() )
        $opTimer : ControlLoopTimer( closedLoopControlName == $event.getClosedLoopControlName(), 
            requestID == $event.getRequestId().toString(), timerType == "Operation", !expired )
        $lock : TargetLock (requestID == $event.getRequestId())
        $response : SOResponseWrapper(requestID.toString() == $event.getRequestId().toString() )
    then

    Logger logger = LoggerFactory.getLogger(drools.getRule().getPackage());
    logger.info("{}: {}", $clName, $params.getPolicyName() + "." + drools.getRule().getName());
    logger.debug("{}: {}: event={} manager={} operation={} lock={} opTimer={} response={}",
                $clName, $params.getPolicyName() + "." + drools.getRule().getName(),
                $event, $manager, $operation, $lock, $operation, $opTimer, $response);

    // Get the result of the operation
    //
    PolicyResult policyResult = $operation.onResponse($response);
    if (policyResult != null) {
        logger.debug("{}: {}: operation finished - result={}",
                    $clName, $params.getPolicyName() + "." + drools.getRule().getName(),
                    policyResult);

        //
        // This Operation has completed, construct a notification showing our results
        //
        VirtualControlLoopNotification notification = new VirtualControlLoopNotification($event);
        notification.setFrom("policy");
        notification.setPolicyName($params.getPolicyName() + "." + drools.getRule().getName());
        notification.setPolicyScope($params.getPolicyScope());
        notification.setPolicyVersion($params.getPolicyVersion());
        notification.setMessage($operation.getOperationHistory());
        notification.setHistory($operation.getHistory());
        if (policyResult.equals(PolicyResult.SUCCESS)) {
            notification.setNotification(ControlLoopNotificationType.OPERATION_SUCCESS);
        } else {
            notification.setNotification(ControlLoopNotificationType.OPERATION_FAILURE);

        }
        PolicyEngine.manager.deliver("POLICY-CL-MGT", notification);
        //
        // Ensure the operation is complete
        //
        if ($operation.isOperationComplete() == true) {
            //
            // It is complete, remove it from memory
            //
            retract($operation);
            //
            // We must also retract the timer object
            // NOTE: We could write a Rule to do this
            //
            retract($opTimer);
            //
            // Complete the operation
            //
            modify($manager) {finishOperation($operation)};
        } else {
            //
            // Just doing this will kick off the LOCKED rule again
            //
            modify($operation) {};
        }
    } else {
        //
        // Its not finished yet (i.e. expecting more Response objects)
        //
        // Or possibly it is a leftover response that we timed the request out previously
        //
    }
    //
    // We are going to retract these objects from memory
    //
    retract($response);

end

/*
*
* This rule responds to VFC Response Events
*
*/
rule "VFC.RESPONSE"
    when
        $params : ControlLoopParams( $clName : getClosedLoopControlName() )
        $event : VirtualControlLoopEvent( closedLoopControlName == $clName, 
            closedLoopEventStatus == ControlLoopEventStatus.ONSET )
        $manager : ControlLoopEventManager( closedLoopControlName == $event.getClosedLoopControlName(), 
            requestID == $event.getRequestId() )
        $operation : ControlLoopOperationManager( onset.closedLoopControlName == $event.getClosedLoopControlName(), 
            onset.getRequestId() == $event.getRequestId() )
        $opTimer : ControlLoopTimer( closedLoopControlName == $event.getClosedLoopControlName(), 
            requestID == $event.getRequestId().toString(), timerType == "Operation", !expired )
        $lock : TargetLock (requestID == $event.getRequestId())
        $response : VfcResponse( requestId.toString() == $event.getRequestId().toString() )
    then
        Logger logger = LoggerFactory.getLogger(drools.getRule().getPackage());
        logger.info("{}: {}", $clName, $params.getPolicyName() + "." + drools.getRule().getName());
        logger.debug("{}: {}: event={} manager={} operation={} lock={} opTimer={} response={}",
                    $clName, $params.getPolicyName() + "." + drools.getRule().getName(),
                    $event, $manager, $operation, $lock, $operation, $opTimer, $response);

        // Get the result of the operation
        //
        PolicyResult policyResult = $operation.onResponse($response);
        if (policyResult != null) {
            //
            // This Operation has completed, construct a notification showing our results
            //
            VirtualControlLoopNotification notification = new VirtualControlLoopNotification($event);
            notification.setFrom("policy");
            notification.setPolicyName($params.getPolicyName() + "." + drools.getRule().getName());
            notification.setPolicyScope($params.getPolicyScope());
            notification.setPolicyVersion($params.getPolicyVersion());
            notification.setMessage($operation.getOperationHistory());
            notification.setHistory($operation.getHistory());
            //
            // Ensure the operation is complete
            //
            if ($operation.isOperationComplete() == true) {
                //
                // It is complete, remove it from memory
                //
                retract($operation);
                //
                // We must also retract the timer object
                // NOTE: We could write a Rule to do this
                //
                retract($opTimer);
                //
                // Complete the operation
                //
                modify($manager) {finishOperation($operation)};
            } else {
                //
                // Just doing this will kick off the LOCKED rule again
                //
                modify($operation) {};
            }
        } else {
            //
            // Its not finished yet (i.e. expecting more Response objects)
            //
            // Or possibly it is a leftover response that we timed the request out previously
            //
        }
        //
        // We are going to retract these objects from memory
        //
        retract($response);

end

/*
*
* This rule responds to SDNC Response Events
*
*/
rule "SDNC.RESPONSE"
    when
        $params : ControlLoopParams( $clName : getClosedLoopControlName() )
        $event : VirtualControlLoopEvent( closedLoopControlName == $clName, closedLoopEventStatus == ControlLoopEventStatus.ONSET )
        $manager : ControlLoopEventManager( closedLoopControlName == $event.getClosedLoopControlName(), requestID == $event.getRequestId() )
        $operation : ControlLoopOperationManager( onset.closedLoopControlName == $event.getClosedLoopControlName(), onset.getRequestId() == $event.getRequestId() )
        $opTimer : ControlLoopTimer( closedLoopControlName == $event.getClosedLoopControlName(), 
            requestID == $event.getRequestId().toString(), timerType == "Operation", !expired )
        $lock : TargetLock (requestID == $event.getRequestId())
        $response : SdncResponse( requestId.toString() == $event.getRequestId().toString() )
    then
        Logger logger = LoggerFactory.getLogger(drools.getRule().getPackage());
        logger.info("{}: {}", $clName, $params.getPolicyName() + "." + drools.getRule().getName());
        logger.debug("{}: {}: event={} manager={} operation={} lock={} opTimer={} response={}",
                	$clName, $params.getPolicyName() + "." + drools.getRule().getName(),
                	$event, $manager, $operation, $lock, $operation, $opTimer, $response);

        // Get the result of the operation
        //
        PolicyResult policyResult = $operation.onResponse($response);
        if (policyResult != null) {
            //
            // This Operation has completed, construct a notification showing our results
            //
            VirtualControlLoopNotification notification = new VirtualControlLoopNotification($event);
            notification.setFrom("policy");
            notification.setPolicyName($params.getPolicyName() + "." + drools.getRule().getName());
            notification.setPolicyScope($params.getPolicyScope());
            notification.setPolicyVersion($params.getPolicyVersion());
            notification.setMessage($operation.getOperationHistory());
            notification.setHistory($operation.getHistory());
            //
            // Ensure the operation is complete
            //
            if ($operation.isOperationComplete()) {
                //
                // It is complete, remove it from memory
                //
                retract($operation);
                //
                // We must also retract the timer object
                // NOTE: We could write a Rule to do this
                //
                retract($opTimer);
                //
                // Complete the operation
                //
                modify($manager) {finishOperation($operation)};
            } else {
                //
                // Just doing this will kick off the LOCKED rule again
                //
                modify($operation) {};
            }
        } else {
            //
            // Its not finished yet (i.e. expecting more Response objects)
            //
            // Or possibly it is a leftover response that we timed the request out previously
            //
        }
        //
        // We are going to retract these objects from memory
        //
        retract($response);

end

/*
*
* This manages a single timer.
* Due to a bug in the drools code, the drools timer needed to be split from most of the objects in the when clause
*
*/
rule "TIMER.FIRED"
    timer (expr: $timeout)
    when
        $timer : ControlLoopTimer($timeout : delay, !expired)
    then
        Logger logger = LoggerFactory.getLogger(drools.getRule().getPackage());
        logger.info("This is TIMER.FIRED");
        modify($timer){setExpired(true)};
    end

/*
*
* This is the timer that manages the timeout for an individual operation.
*
*/
rule "EVENT.MANAGER.OPERATION.TIMEOUT"
    when
        $params : ControlLoopParams( $clName : getClosedLoopControlName() )
        $event : VirtualControlLoopEvent( closedLoopControlName == $clName )
        $manager : ControlLoopEventManager( closedLoopControlName == $event.getClosedLoopControlName(), 
            requestID == $event.getRequestId() )
        $operation : ControlLoopOperationManager( onset.closedLoopControlName == $event.getClosedLoopControlName(), 
            onset.getRequestId() == $event.getRequestId() )
        $opTimer : ControlLoopTimer( closedLoopControlName == $event.getClosedLoopControlName(), 
            requestID == $event.getRequestId().toString(), timerType == "Operation", expired )
        $lock : TargetLock (requestID == $event.getRequestId())
    then

    Logger logger = LoggerFactory.getLogger(drools.getRule().getPackage());
    logger.info("{}: {}", $clName, $params.getPolicyName() + "." + drools.getRule().getName());
    logger.debug("{}: {}: event={} manager={} operation={} lock={} opTimer={}",
                $clName, $params.getPolicyName() + "." + drools.getRule().getName(),
                $event, $manager, $operation, $lock, $operation, $opTimer);

    //
    // Tell it its timed out
    //
    $operation.setOperationHasTimedOut();
    //
    // Create a notification for it ("DB Write - end operation")
    //
    VirtualControlLoopNotification notification = new VirtualControlLoopNotification($event);
    notification.setFrom("policy");
    notification.setPolicyName($params.getPolicyName() + "." + drools.getRule().getName());
    notification.setPolicyScope($params.getPolicyScope());
    notification.setPolicyVersion($params.getPolicyVersion());
    notification.setNotification(ControlLoopNotificationType.OPERATION_FAILURE);
    notification.setMessage($operation.getOperationHistory());
    notification.setHistory($operation.getHistory());
    //
    // Let interested parties know
    //
    PolicyEngine.manager.deliver("POLICY-CL-MGT", notification);
    //
    // Get rid of the timer
    //
    retract($opTimer);
    //
    // Ensure the operation is complete
    //
    if ($operation.isOperationComplete() == true) {
        //
        // It is complete, remove it from memory
        //
        retract($operation);
        //
        // Complete the operation
        //
        modify($manager) {finishOperation($operation)};
    } else {
        //
        // Just doing this will kick off the LOCKED rule again
        //
        modify($operation) {};
    }
end

/*
*
* This is the timer that manages the overall control loop timeout.
*
*/
rule "EVENT.MANAGER.TIMEOUT"
    when
        $params : ControlLoopParams( $clName : getClosedLoopControlName() )
        $event : VirtualControlLoopEvent( closedLoopControlName == $clName )
        $manager : ControlLoopEventManager( closedLoopControlName == $event.getClosedLoopControlName(), 
            requestID == $event.getRequestId() )
        $clTimer : ControlLoopTimer( closedLoopControlName == $event.getClosedLoopControlName(), 
            requestID == $event.getRequestId().toString(), timerType == "ClosedLoop", expired )
    then

    Logger logger = LoggerFactory.getLogger(drools.getRule().getPackage());
    logger.info("{}: {}", $clName, $params.getPolicyName() + "." + drools.getRule().getName());

    logger.debug("{}: {}: event={}",
              $clName, $params.getPolicyName() + "." + drools.getRule().getName(),
              $event);
    //
    // Tell the Event Manager it has timed out
    //
    VirtualControlLoopNotification notification = $manager.setControlLoopTimedOut();
    if (notification != null) {
        notification.setFrom("policy");
        notification.setPolicyName($params.getPolicyName() + "." + drools.getRule().getName());
        notification.setPolicyScope($params.getPolicyScope());
        notification.setPolicyVersion($params.getPolicyVersion());
        //
        // Let interested parties know
        //
        PolicyEngine.manager.deliver("POLICY-CL-MGT", notification);
    }
    //
    // Retract the event
    //
    retract($event);
end

/*
*
* This rule cleans up the manager and other objects after an event has
* been retracted.
*
*/
rule "EVENT.MANAGER.CLEANUP"
    when
        $manager : ControlLoopEventManager( $clName : getClosedLoopControlName(), $requestId : getRequestID() )
        $operations : LinkedList()
                        from collect( ControlLoopOperationManager( onset.closedLoopControlName == $clName, 
                            onset.getRequestId() == $requestId ) )
        $timers : LinkedList()
                        from collect( ControlLoopTimer( closedLoopControlName == $clName, 
                            requestID == $requestId.toString() ) )
        $locks : LinkedList()
                        from collect( TargetLock (requestID == $requestId) )
        not( VirtualControlLoopEvent( closedLoopControlName == $clName, requestId == $requestId ) )
    then

    Logger logger = LoggerFactory.getLogger(drools.getRule().getPackage());
    logger.info("{}: {}", $clName, drools.getRule().getName());

    logger.debug("{}: {}: manager={} timers={} operations={}",
              $clName, drools.getRule().getName(),
              $manager, $timers.size(), $operations.size());

    //
    // Retract EVERYTHING
    //
    retract($manager);

    for(Object manager: $operations) {
        retract((ControlLoopOperationManager) manager);
    }
    for(Object timer: $timers) {
        retract((ControlLoopTimer) timer);
    }
    for(Object lock: $locks) {
        TargetLock tgt = (TargetLock) lock;
        //
        // Ensure we release the lock
        //
        PolicyGuard.unlockTarget(tgt);
        retract(tgt);
    }
end

/*
*
* This rule will clean up any rogue onsets where there is no
* ControlLoopParams object corresponding to the onset event.
*
*/
rule "EVENT.CLEANUP"
    when
        $event : VirtualControlLoopEvent( $clName: closedLoopControlName )
        not ( ControlLoopParams( getClosedLoopControlName() == $clName) )
    then

    Logger logger = LoggerFactory.getLogger(drools.getRule().getPackage());
    logger.info("{}: {}", $clName, drools.getRule().getName());
    logger.debug("{}: {}: orphan onset event={}",
                $clName, drools.getRule().getName(), $event);

    retract($event);
end

/*
*
* This rule responds to SDNR Response Events.
*
*/
rule "SDNR.RESPONSE"
    when
        $params : ControlLoopParams( $clName : getClosedLoopControlName() )
        $event : VirtualControlLoopEvent( closedLoopControlName == $clName, 
            closedLoopEventStatus == ControlLoopEventStatus.ONSET )
        $manager : ControlLoopEventManager( closedLoopControlName == $event.getClosedLoopControlName(), 
            requestID == $event.getRequestId() )
        $operation : ControlLoopOperationManager( onset.closedLoopControlName == $event.getClosedLoopControlName(), 
            onset.getRequestId() == $event.getRequestId() )
        $opTimer : ControlLoopTimer( closedLoopControlName == $event.getClosedLoopControlName(), 
            requestID == $event.getRequestId().toString(), timerType == "Operation", !expired )
        $lock : TargetLock (requestID == $event.getRequestId())
        $response : PciResponseWrapper( getBody().getCommonHeader().getRequestId() == $event.getRequestId() )
    then

    Logger logger = LoggerFactory.getLogger(drools.getRule().getPackage());
    logger.info("{}: {}", $clName, $params.getPolicyName() + "." + drools.getRule().getName());
    logger.debug("{}: {}: event={} manager={} operation={} lock={} opTimer={} response={}",
                $clName, $params.getPolicyName() + "." + drools.getRule().getName(),
                $event, $manager, $operation, $lock, $operation, $opTimer, $response);

    //
    // Get the result of the operation
    //
    PolicyResult policyResult = $operation.onResponse($response);
    if (policyResult != null) {
      logger.debug("{}: {}: operation finished - result={}",
                  $clName, $params.getPolicyName() + "." + drools.getRule().getName(),
                  policyResult);

      //
      // This Operation has completed, construct a notification showing our results. (DB write - end operation)
      //
      VirtualControlLoopNotification notification = new VirtualControlLoopNotification($event);
      notification.setFrom("policy");
      notification.setPolicyName($params.getPolicyName() + "." + drools.getRule().getName());
      notification.setPolicyScope($params.getPolicyScope());
      notification.setPolicyVersion($params.getPolicyVersion());
      notification.setMessage($operation.getOperationHistory());
      notification.setHistory($operation.getHistory());
      if (policyResult.equals(PolicyResult.SUCCESS)) {
          notification.setNotification(ControlLoopNotificationType.OPERATION_SUCCESS);
      } else {
          notification.setNotification(ControlLoopNotificationType.OPERATION_FAILURE);
      }
      PolicyEngine.manager.deliver("POLICY-CL-MGT", notification);
      //
      // Ensure the operation is complete
      //
      if ($operation.isOperationComplete() == true) {
          //
          // It is complete, remove it from memory
          //
          retract($operation);
          //
          // We must also retract the timer object
          // NOTE: We could write a Rule to do this
          //
          retract($opTimer);
          //
          // Complete the operation
          //
          modify($manager) {finishOperation($operation)};
      } else {
          //
          // Just doing this will kick off the LOCKED rule again
          //
          modify($operation) {};
      }
    } else {
        //
        // Its not finished yet (i.e. expecting more Response objects)
        //
        // Or possibly it is a leftover response that we timed the request out previously
        //
    }
    //
    // We are going to retract these objects from memory
    //
    retract($response);
end

/*
*
* Clean Up any lingering SDNR reponses.
*
*/
rule "SDNR.RESPONSE.CLEANUP"
    when
        $params : ControlLoopParams( $clName : getClosedLoopControlName() )
        $response : PciResponseWrapper($id : getBody().getCommonHeader().getRequestId )
        not ( VirtualControlLoopEvent( requestId == $id, closedLoopEventStatus == ControlLoopEventStatus.ONSET ) )
    then

    Logger logger = LoggerFactory.getLogger(drools.getRule().getPackage());
    logger.info("{}: {}", $clName, $params.getPolicyName() + "." + drools.getRule().getName());
    logger.debug("{}: {}: orphan sdnr response={}",
                $clName, $params.getPolicyName() + "." + drools.getRule().getName(), $id);
    //
    // Retract it
    //
    retract($response);
end
