/*
 * ============LICENSE_START=======================================================
 * ONAP
 * ================================================================================
 * Copyright (C) 2017-2018 AT&T Intellectual Property. All rights reserved.
 * ================================================================================
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ============LICENSE_END=========================================================
 */

package org.onap.policy.controlloop;

import org.onap.policy.controlloop.VirtualControlLoopEvent;
import org.onap.policy.controlloop.VirtualControlLoopNotification;
import org.onap.policy.controlloop.ControlLoopEventStatus;
import org.onap.policy.controlloop.ControlLoopNotificationType;
import org.onap.policy.controlloop.ControlLoopLogger;
import org.onap.policy.controlloop.policy.PolicyResult;
import org.onap.policy.controlloop.policy.ControlLoopPolicy;
import org.onap.policy.controlloop.policy.Policy;
import org.onap.policy.controlloop.eventmanager.ControlLoopEventManager;
import org.onap.policy.controlloop.eventmanager.ControlLoopEventManager.NEW_EVENT_STATUS;
import org.onap.policy.controlloop.eventmanager.ControlLoopOperationManager;
import org.onap.policy.controlloop.actor.so.SoActorServiceProvider;
import org.onap.policy.aai.AaiNqResponseWrapper;
import org.onap.policy.appc.Request;
import org.onap.policy.appc.Response;
import org.onap.policy.appc.CommonHeader;
import org.onap.policy.appclcm.LcmRequestWrapper;
import org.onap.policy.appclcm.LcmResponseWrapper;
import org.onap.policy.appclcm.LcmRequest;
import org.onap.policy.appclcm.LcmResponse;
import org.onap.policy.appclcm.LcmCommonHeader;
import org.onap.policy.sdnr.PciRequestWrapper;
import org.onap.policy.sdnr.PciResponseWrapper;
import org.onap.policy.sdnr.PciRequest;
import org.onap.policy.sdnr.PciResponse;
import org.onap.policy.vfc.VFCRequest;
import org.onap.policy.vfc.VFCResponse;
import org.onap.policy.vfc.VFCManager;
import org.onap.policy.so.SOManager;
import org.onap.policy.so.SORequest;
import org.onap.policy.so.SORequestStatus;
import org.onap.policy.so.SORequestDetails;
import org.onap.policy.so.SOModelInfo;
import org.onap.policy.so.SOCloudConfiguration;
import org.onap.policy.so.SORequestInfo;
import org.onap.policy.so.SORequestParameters;
import org.onap.policy.so.SORelatedInstanceListElement;
import org.onap.policy.so.SORelatedInstance;
import org.onap.policy.so.SOResponse;
import org.onap.policy.so.SOResponseWrapper;
import org.onap.policy.sdnc.SdncRequest;
import org.onap.policy.sdnc.SdncManager;
import org.onap.policy.sdnc.SdncResponse;
import org.onap.policy.guard.PolicyGuard;
import org.onap.policy.guard.PolicyGuard.LockResult;
import org.onap.policy.guard.TargetLock;
import org.onap.policy.guard.GuardResult;
import org.onap.policy.guard.PolicyGuardRequest;
import org.onap.policy.guard.PolicyGuardResponse;
import org.onap.policy.guard.PolicyGuardXacmlRequestAttributes;
import org.onap.policy.guard.PolicyGuardXacmlHelper;

import org.yaml.snakeyaml.Yaml;
import org.yaml.snakeyaml.constructor.Constructor;

import org.slf4j.LoggerFactory;
import org.slf4j.Logger;

import java.time.Instant;
import java.util.LinkedList;
import java.util.Iterator;
import java.util.HashSet;
import java.util.Set;

import org.onap.policy.drools.system.PolicyEngine;

/*
 * This structure mimics the Params structure.
 * Its only purpose is to allow management of
 * rules by the PAP component..
 * It has no use at runtime since the rules go by
 * Params for matching purposes.
 */
declare PapParams
  closedLoopControlName : String
  controlLoopYaml : String
end

/*
 * Control Loop Identity
 */
declare Params
  closedLoopControlName : String
  controlLoopYaml : String
end

/*
 * Used to clean up Params that no longer have associated rules.
 */
declare ParamsCleaner
  closedLoopControlName : String
  identified : boolean              // true if all active Params have been identified
  active : Set                      // Params that are still active
end

/*
 * This object is to provide support for timeouts
 * due to a bug in drools' built-in timers
 */
declare ControlLoopTimer
    closedLoopControlName : String
    requestID : String
    delay : String
    expired : boolean
    //timerType is the type of timer: either "ClosedLoop" or "Operation"
    timerType : String
end

/*
*
* Called once and only once to insert the parameters into working memory for this Closed Loop policy.
* This has a higher salience so we can ensure that the Params is created before we have a chance to
* discard any events.
*
*/
rule "${policyName}.SETUP"
    salience 1
    when
        not( Params( getClosedLoopControlName() == "${closedLoopControlName}", 
            getControlLoopYaml() == "${controlLoopYaml}" ) )
    then
    
    Params params = new Params();
    params.setClosedLoopControlName("${closedLoopControlName}");
    params.setControlLoopYaml("${controlLoopYaml}");
    insert(params);
    
    ParamsCleaner cleaner = new ParamsCleaner();
    cleaner.setClosedLoopControlName("${closedLoopControlName}");
    cleaner.setIdentified(false);
    cleaner.setActive(new HashSet());
    insert(cleaner);

    // Note: globals have bad behavior when persistence is used,
    //       hence explicitly getting the logger vs using a global
    
    Logger logger = LoggerFactory.getLogger(drools.getRule().getPackage());
    logger.info("{}: {} : YAML=[{}]", params.getClosedLoopControlName(), drools.getRule().getName(), 
        params.getControlLoopYaml());
end

/*
*
* This rule responds to DCAE Events where there is no manager yet. Either it is
* the first ONSET, or a subsequent badly formed Event (i.e. Syntax error, or is-closed-loop-disabled)
*
*/
rule "${policyName}.EVENT"
    when
        $params : Params( getClosedLoopControlName() == "${closedLoopControlName}" )
        $event : VirtualControlLoopEvent( closedLoopControlName == $params.getClosedLoopControlName() )
        not ( ControlLoopEventManager( closedLoopControlName == $event.getClosedLoopControlName(), 
            requestID == $event.getRequestId() ) )
    then
 
    Logger logger = LoggerFactory.getLogger(drools.getRule().getPackage());
    logger.info("{}: {}", $params.getClosedLoopControlName(), drools.getRule().getName());
    
    try {
      
        //
        // Check the event, because we need it to not be null when
        // we create the ControlLoopEventManager. The ControlLoopEventManager
        // will do extra syntax checking as well check if the closed loop is disabled.
        //
        if ($event.getRequestId() == null) {
            VirtualControlLoopNotification notification = new VirtualControlLoopNotification($event);
            notification.setNotification(ControlLoopNotificationType.REJECTED);
            notification.setFrom("policy");
            notification.setMessage("Missing requestId");
            notification.setPolicyName(drools.getRule().getName());
            notification.setPolicyScope("${policyScope}");
            notification.setPolicyVersion("${policyVersion}");
            
            //
            // Let interested parties know
            //
            PolicyEngine.manager.deliver("POLICY-CL-MGT", notification);
            
            //
            // Retract it from memory
            //
            retract($event);
        } else if ($event.getClosedLoopEventStatus() != ControlLoopEventStatus.ONSET) {
            throw new ControlLoopException($event.getClosedLoopEventStatus() + " received with no prior onset");
        } else {
            //
            // Create an EventManager
            //
            ControlLoopEventManager manager = new ControlLoopEventManager($params.getClosedLoopControlName(), 
                $event.getRequestId());
            //
            // Determine if EventManager can actively process the event 
            // (i.e. syntax, is_closed_loop_disabled checks etc.)
            //
            VirtualControlLoopNotification notification = manager.activate($params.getControlLoopYaml(), $event);
            notification.setFrom("pdp-0001-controller=controlloop"); // Engine.getInstanceName()
            notification.setPolicyName(drools.getRule().getName());
            notification.setPolicyScope("${policyScope}");
            notification.setPolicyVersion("${policyVersion}");
            //
            // Are we actively pursuing this event?
            //
            if (notification.getNotification() == ControlLoopNotificationType.ACTIVE) {
                //
                // Insert Event Manager into memory, this will now kick off processing.
                //
                insert(manager);
                //
                // Let interested parties know
                //
                PolicyEngine.manager.deliver("POLICY-CL-MGT", notification);
                //
                // Setup the Overall Control Loop timer
                //
                ControlLoopTimer clTimer = new ControlLoopTimer();
                clTimer.setTimerType("ClosedLoop");
                clTimer.setClosedLoopControlName($event.getClosedLoopControlName());
                clTimer.setRequestID($event.getRequestId().toString());
                clTimer.setDelay(manager.getControlLoopTimeout(1500) + "s");
                //
                // Insert it
                //
                insert(clTimer);
            } else {
                //
                // Let interested parties know
                //
                PolicyEngine.manager.deliver("POLICY-CL-MGT", notification);
                //
                // Retract it from memory
                //
                retract($event);
            }
            
            //
            // Now that the manager is inserted into Drools working memory, we'll wait for
            // another rule to fire in order to continue processing. This way we can also
            // then screen for additional ONSET and ABATED events for this RequestId.
            //
        }
    } catch (Exception e) {
        logger.warn("{}: {}", $params.getClosedLoopControlName(), drools.getRule().getName(), e);
        
        VirtualControlLoopNotification notification = new VirtualControlLoopNotification($event);
        notification.setNotification(ControlLoopNotificationType.REJECTED);
        notification.setMessage("Exception occurred: " + e.getMessage());
        notification.setPolicyName(drools.getRule().getName());
        notification.setPolicyScope("${policyScope}");
        notification.setPolicyVersion("${policyVersion}");
        //
        //
        //
        PolicyEngine.manager.deliver("POLICY-CL-MGT", notification);
        //
        // Retract the event
        //
        retract($event);
    }
end

/*
*
* This rule happens when we got a valid ONSET, closed loop is enabled and an Event Manager
* is now created. We can start processing the yaml specification via the Event Manager.
*
*/
rule "${policyName}.EVENT.MANAGER"
    when
        $params : Params( getClosedLoopControlName() == "${closedLoopControlName}" )
        $event : VirtualControlLoopEvent( closedLoopControlName == $params.getClosedLoopControlName() )
        $manager : ControlLoopEventManager( closedLoopControlName == $event.getClosedLoopControlName(), 
            requestID == $event.getRequestId() )
        $clTimer : ControlLoopTimer( closedLoopControlName == $event.getClosedLoopControlName(), 
            requestID == $event.getRequestId().toString(), timerType == "ClosedLoop", !expired )
    then

    Logger logger = LoggerFactory.getLogger(drools.getRule().getPackage());
    logger.info("{}: {}: event={} manager={} clTimer={}", 
                $params.getClosedLoopControlName(), drools.getRule().getName(),
                $event, $manager, $clTimer);
    
    try {
        //
        // Check which event this is.
        //
        ControlLoopEventManager.NEW_EVENT_STATUS eventStatus = $manager.onNewEvent($event);
        //
        // Check what kind of event this is
        //
        if (eventStatus == NEW_EVENT_STATUS.SUBSEQUENT_ONSET) {
            //
            // We don't care about subsequent onsets
            //
            logger.info("{}: {}: subsequent onset", 
                        $params.getClosedLoopControlName(), drools.getRule().getName());
            retract($event);
            return;
        }
        if (eventStatus == NEW_EVENT_STATUS.SYNTAX_ERROR) {
            //
            // Ignore any bad syntax events
            //
            logger.warn("{}: {}: syntax error", 
                        $params.getClosedLoopControlName(), drools.getRule().getName());
            retract($event);
            return;
        }
        //
        // We only want the initial ONSET event in memory,
        // all the other events need to be retracted to support
        // cleanup and avoid the other rules being fired for this event.
        //
        if (eventStatus != NEW_EVENT_STATUS.FIRST_ONSET) {
            logger.warn("{}: {}: not first onset", 
                        $params.getClosedLoopControlName(), drools.getRule().getName());
            retract($event);
        }
        
        logger.debug("{}: {}: target={}", $params.getClosedLoopControlName(), 
                     drools.getRule().getName(), $event.getTarget());
        //
        // Now start seeing if we need to process this event
        //

        //
        // Check if this is a Final Event
        //
        VirtualControlLoopNotification notification = $manager.isControlLoopFinal();
    
    
        if (notification != null) {
            //
            // Its final, but are we waiting for abatement?
            //
            if ($manager.getNumAbatements() > 0) {
                logger.info("{}: {}: abatement received for {}.  Closing the control loop", 
                            $params.getClosedLoopControlName(), drools.getRule().getName(), 
                            $event.getRequestId());
                
                /// DB Write---end event processing for this RequestId()
                $manager.commitAbatement("Event Abated","Closed");
                
                notification.setFrom("policy");
                notification.setPolicyName(drools.getRule().getName());
                notification.setPolicyScope("${policyScope}");
                notification.setPolicyVersion("${policyVersion}");
                //
                // In this case, we are done
                //
                PolicyEngine.manager.deliver("POLICY-CL-MGT", notification);
                //
                // Unlock the target
                //
                TargetLock lock = $manager.unlockCurrentOperation();
                if (lock != null) {
                    logger.debug("{}: {}: retracting lock=", $params.getClosedLoopControlName(), 
                                 drools.getRule().getName(), lock);
                    retract(lock);
                }
                //
                // Retract everything from memory
                //
                logger.info("{}: {}: retracting onset, manager, and timer", 
                            $params.getClosedLoopControlName(), drools.getRule().getName());
                
                retract($manager.getOnsetEvent());
                
                // don't retract manager, etc. - a clean-up rule will do that
                
                //
                // TODO - what if we get subsequent Events for this RequestId?
                // By default, it will all start over again. May be confusing for Ruby.
                // Or, we could track this and then subsequently ignore the events
                //
            } else {
                //
                // Check whether we need to wait for abatement
                //
                if ($manager.getProcessor().getControlLoop().getAbatement() == true && notification.getNotification() == ControlLoopNotificationType.FINAL_SUCCESS) {
                  logger.info("{}: {}: waiting for abatement ..", 
                              $params.getClosedLoopControlName(), drools.getRule().getName());
                } else {
                  logger.info("{}: {}: no abatement expect for {}.  Closing the control loop", 
                              $params.getClosedLoopControlName(), drools.getRule().getName(), 
                              $event.getRequestId());
                  
                  notification.setFrom("policy");
                  notification.setPolicyName(drools.getRule().getName());
                  notification.setPolicyScope("${policyScope}");
                  notification.setPolicyVersion("${policyVersion}");
                  
                  //
                  // In this case, we are done
                  //
                  PolicyEngine.manager.deliver("POLICY-CL-MGT", notification);
                  //
                  // Unlock the target
                  //
                  TargetLock lock = $manager.unlockCurrentOperation();
                  if (lock != null) {
                      logger.debug("{}: {}: retracting lock=", $params.getClosedLoopControlName(), 
                                  drools.getRule().getName(), lock);
                      retract(lock);
                  }
                  //
                  // Retract everything from memory
                  //
                  logger.info("{}: {}: retracting onset, manager, and timer", 
                              $params.getClosedLoopControlName(), drools.getRule().getName());
                  
                  retract($manager.getOnsetEvent());
                
                // don't retract manager, etc. - a clean-up rule will do that
                }
            }
        } else {
            //
            // NOT final, so let's ask for the next operation
            //
            ControlLoopOperationManager operation = $manager.processControlLoop();
            if (operation != null) {
              //
              // Let's ask for a lock right away
              //
              LockResult<GuardResult, TargetLock> result = $manager.lockCurrentOperation();
              logger.info("{}: {}: guard lock acquired={}", 
                            $params.getClosedLoopControlName(), drools.getRule().getName(), 
                            result.getB());
              if (result.getA().equals(GuardResult.LOCK_ACQUIRED)) {
                  //
                  // insert the operation into memory
                  //
                  insert(operation);
                  //
                  // insert operation timeout object
                  //
                   ControlLoopTimer opTimer = new ControlLoopTimer();
                   opTimer.setTimerType("Operation");
                   opTimer.setClosedLoopControlName($event.getClosedLoopControlName());
                   opTimer.setRequestID($event.getRequestId().toString());
                   opTimer.setDelay(operation.getOperationTimeout().toString() + "s");
                  insert(opTimer);
              
                  //
                  // Insert lock into memory
                  //
                  insert(result.getB());
              } else {
                   logger.debug("The target resource {} is already processing",
                            $event.getAai().get($event.getTarget()));
                  notification = new VirtualControlLoopNotification($event);
                  notification.setNotification(ControlLoopNotificationType.REJECTED);
                  notification.setMessage("The target " + $event.getAai().get($event.getTarget()) 
                      + " is already locked");
                  notification.setFrom("policy");
                  notification.setPolicyName(drools.getRule().getName());
                  notification.setPolicyScope("${policyScope}");
                  notification.setPolicyVersion("${policyVersion}");
      
                  PolicyEngine.manager.deliver("POLICY-CL-MGT", notification);

                  retract($event);
                
                  // don't retract manager, etc. - a clean-up rule will do that

                  if (result.getB() != null) {
                      retract(result.getB());
                  }
              }
              logger.info("{}: {}: starting operation={}", 
                          $params.getClosedLoopControlName(), drools.getRule().getName(), 
                          operation);
            } else {
                //
                // Probably waiting for abatement
                //
              logger.info("{}: {}: no operation, probably waiting for abatement", 
                          $params.getClosedLoopControlName(), drools.getRule().getName());
            }
        }
    } catch (Exception e) {
         logger.warn("{}: {}: unexpected", 
                  $params.getClosedLoopControlName(), 
                  drools.getRule().getName(), e);

         VirtualControlLoopNotification notification = new VirtualControlLoopNotification($event);
         notification.setNotification(ControlLoopNotificationType.FINAL_FAILURE);
         notification.setMessage(e.getMessage());
         notification.setFrom("policy");
         notification.setPolicyName(drools.getRule().getName());
         notification.setPolicyScope("${policyScope}");
         notification.setPolicyVersion("${policyVersion}");
  
         PolicyEngine.manager.deliver("POLICY-CL-MGT", notification);

         retract($event);
                
         // don't retract manager, etc. - a clean-up rule will do that
    }
        
end

/*
*
* Guard Permitted, let's send request to the actor.
*
*/
rule "${policyName}.EVENT.MANAGER.OPERATION.LOCKED.GUARD_PERMITTED"
    when
        $params : Params( getClosedLoopControlName() == "${closedLoopControlName}" )
        $event : VirtualControlLoopEvent( closedLoopControlName == $params.getClosedLoopControlName() )
        $manager : ControlLoopEventManager( closedLoopControlName == $event.getClosedLoopControlName(), 
            requestID == $event.getRequestId() )
        $operation : ControlLoopOperationManager( onset.closedLoopControlName == $event.getClosedLoopControlName(), 
            onset.getRequestId() == $event.getRequestId(), "Permit".equalsIgnoreCase(getGuardApprovalStatus()) )
        $lock : TargetLock (requestID == $event.getRequestId())
        $opTimer : ControlLoopTimer( closedLoopControlName == $event.getClosedLoopControlName(), 
            requestID == $event.getRequestId().toString(), timerType == "Operation", !expired )
    then

    Logger logger = LoggerFactory.getLogger(drools.getRule().getPackage());
    logger.info("{}: {}: event={} manager={} operation={} lock={}", 
                $params.getClosedLoopControlName(), drools.getRule().getName(),
                $event, $manager, $operation, $lock);    

    Object request = null;
    boolean caughtException = false;
    
    try {
        request = $operation.startOperation($event);
        
        if (request != null) {
          logger.debug("{}: {}: starting operation ..", 
                       $params.getClosedLoopControlName(), drools.getRule().getName());
          //
          // Tell interested parties we are performing this Operation
          //
          VirtualControlLoopNotification notification = new VirtualControlLoopNotification($event);
          notification.setNotification(ControlLoopNotificationType.OPERATION);
          notification.setMessage($operation.getOperationMessage());
          notification.setHistory($operation.getHistory());
          notification.setFrom("policy");
          notification.setPolicyName(drools.getRule().getName());
          notification.setPolicyScope("${policyScope}");
          notification.setPolicyVersion("${policyVersion}");

          PolicyEngine.manager.deliver("POLICY-CL-MGT", notification);

          switch ($operation.policy.getActor()){

              case "APPC":
                  if (request instanceof Request) {
                      PolicyEngine.manager.deliver("APPC-CL", request);
                  }
                  else if (request instanceof LcmRequestWrapper) {
                      PolicyEngine.manager.deliver("APPC-LCM-READ", request);
                  }
                  break;
              case "SO":
                  // at this point the AAI named query request should have already been made, 
                  // the response recieved and used
                  // in the construction of the SO Request which is stored in operationRequest

                  if(request instanceof SORequest) {
                      // Call SO. The response will be inserted into memory once it's received 
                      SoActorServiceProvider.sendRequest($event.getRequestId().toString(), drools.getWorkingMemory(),
                          request);                        
                  }
                  break;
              case "VFC":
                  if (request instanceof VFCRequest) {
                      // Start VFC thread
                      Thread t = new Thread(new VFCManager(drools.getWorkingMemory(), (VFCRequest)request));
                      t.start();
                  }          
                  break;
                
              case "SDNC":
                  if (request instanceof SdncRequest) {
                     // Start SDNC thread
                     Thread t = new Thread(new SdncManager(drools.getWorkingMemory(), (SdncRequest)request));
                     t.start();
                  }
                  break;                       
              case "SDNR":
                  if (request instanceof PciRequestWrapper) {
                      PolicyEngine.manager.deliver("SDNR-CL", request);
                  }
                  break;
          }
        } else {
          //
          // What happens if its null?
          //
            logger.warn("{}: {}: unexpected null operation request", 
                      $params.getClosedLoopControlName(), 
                      drools.getRule().getName());
            if ("SO".equals($operation.policy.getActor())) {
                retract($opTimer);
                retract($operation);
                modify($manager) {finishOperation($operation)};
            }
            else if ("vfc".equalsIgnoreCase($operation.policy.getActor())) {
                retract($opTimer);
                retract($operation);
                modify($manager) {finishOperation($operation)};
            }
            else if ("sdnc".equalsIgnoreCase($operation.policy.getActor())) {
                retract($opTimer);
                retract($operation);
                modify($manager) {finishOperation($operation)};
            }
        }
        
    } catch (Exception e) {
        String msg = e.getMessage();
        logger.warn("{}: {}: operation={}:  AAI failure: {}", 
                    $params.getClosedLoopControlName(), drools.getRule().getName(),
                    $operation, msg, e);
        $operation.setOperationHasException(msg);
        
        if(request != null) {
            //
            // Create a notification for it ("DB Write - end operation")
            //
            VirtualControlLoopNotification notification = new VirtualControlLoopNotification($event);
            notification.setFrom("policy");
            notification.setPolicyName(drools.getRule().getName());
            notification.setPolicyScope("${policyScope}");
            notification.setPolicyVersion("${policyVersion}");
            notification.setNotification(ControlLoopNotificationType.OPERATION_FAILURE);
            notification.setMessage($operation.getOperationHistory());
            notification.setHistory($operation.getHistory());
          
            PolicyEngine.manager.deliver("POLICY-CL-MGT", notification);
        }
    
        retract($opTimer);
        retract($operation);
        caughtException = true;
    }
    
    // Having the modify statement in the catch clause doesn't work for whatever reason
    if (caughtException) {
        modify($manager) {finishOperation($operation)};
    }
end


/*
*
* We were able to acquire a lock so now let's ask Xacml Guard whether 
* we are allowed to proceed with the request to the actor.
*
*/
rule "${policyName}.EVENT.MANAGER.OPERATION.LOCKED.GUARD_NOT_YET_QUERIED"
    when
        $params : Params( getClosedLoopControlName() == "${closedLoopControlName}" )
        $event : VirtualControlLoopEvent( closedLoopControlName == $params.getClosedLoopControlName() )
        $manager : ControlLoopEventManager( closedLoopControlName == $event.getClosedLoopControlName(), 
            requestID == $event.getRequestId() )
        $operation : ControlLoopOperationManager( onset.closedLoopControlName == $event.getClosedLoopControlName(), 
            onset.getRequestId() == $event.getRequestId(), getGuardApprovalStatus() == "NONE" )
        $lock : TargetLock (requestID == $event.getRequestId())
    then

    Logger logger = LoggerFactory.getLogger(drools.getRule().getPackage());
    logger.info("{}: {}: event={} manager={} operation={} lock={}", 
                $params.getClosedLoopControlName(), drools.getRule().getName(),
                $event, $manager, $operation, $lock);
    
    //
    // Sending notification that we are about to query Guard ("DB write - start operation")
    //
    VirtualControlLoopNotification notification = new VirtualControlLoopNotification($event);
    notification.setNotification(ControlLoopNotificationType.OPERATION);
    notification.setMessage("Sending guard query for " + $operation.policy.getActor() + " " 
        + $operation.policy.getRecipe());
    notification.setHistory($operation.getHistory());
    notification.setFrom("policy");
    notification.setPolicyName(drools.getRule().getName());
    notification.setPolicyScope("${policyScope}");
    notification.setPolicyVersion("${policyVersion}");
    
    PolicyEngine.manager.deliver("POLICY-CL-MGT", notification);
        
    //
    // Now send Guard Request to XACML Guard. In order to bypass the call to Guard, 
    // just change guardEnabled to false.
    // 
    // In order to use REST XACML, provide a URL instead of "" as a second argument 
    // to the CallGuardTask() and set the first argument to null 
    // (instead of XacmlPdpEngine).
    //
    
    // NOTE: The environment properties uses "guard.disabled" but the boolean is guardEnabled
    boolean guardEnabled = "false".equalsIgnoreCase(PolicyEngine.manager.getEnvironmentProperty("guard.disabled"));
    
    if(guardEnabled){
    
        Thread t = new Thread(new org.onap.policy.guard.CallGuardTask(
                                                        drools.getWorkingMemory(),
                                                        $event.getClosedLoopControlName(),
                                                        $operation.policy.getActor().toString(),
                                                        $operation.policy.getRecipe(),
                                                        $operation.getTargetEntity(),
                                                        $event.getRequestId().toString(),
                                                        () -> {
                                                            AaiNqResponseWrapper resp = $manager.getNqVserverFromAai();
                                                            return(resp == null ? null : resp.countVfModules());
                                                        }));
        t.start();
    }
    else{
        insert(new PolicyGuardResponse("Permit", $event.getRequestId(), $operation.policy.getRecipe()));
    }

end

//
// This rule will be triggered when a thread talking to the XACML Guard inserts a 
// guardResponse object into the working memory
//
rule "${policyName}.GUARD.RESPONSE"
    when
        $params : Params( getClosedLoopControlName() == "${closedLoopControlName}" )
        $event : VirtualControlLoopEvent( closedLoopControlName == $params.getClosedLoopControlName(), 
            closedLoopEventStatus == ControlLoopEventStatus.ONSET )
        $manager : ControlLoopEventManager( closedLoopControlName == $event.getClosedLoopControlName(), 
            requestID == $event.getRequestId() ) 
        $operation : ControlLoopOperationManager( onset.closedLoopControlName == $event.getClosedLoopControlName(), 
            onset.getRequestId() == $event.getRequestId() )
        $lock : TargetLock (requestID == $event.getRequestId())
        $opTimer : ControlLoopTimer( closedLoopControlName == $event.getClosedLoopControlName(), 
            requestID == $event.getRequestId().toString(), timerType == "Operation", !expired )
        $guardResponse : PolicyGuardResponse(requestID == $event.getRequestId(), $operation.policy.recipe == operation)
    then

    Logger logger = LoggerFactory.getLogger(drools.getRule().getPackage());
    logger.info("{}: {}: event={} manager={} operation={} lock={} opTimer={} guardResponse={}", 
                 $params.getClosedLoopControlName(), drools.getRule().getName(),
                 $event, $manager, $operation, $lock, $opTimer, $guardResponse);
        
        
    //we will permit the operation if there was no Guard for it
    if("Indeterminate".equalsIgnoreCase($guardResponse.getResult())){
        $guardResponse.setResult("Permit");
    }
    
    //
    // This notification has Guard result in "message". ("DB write - end operation in case of Guard Deny")
    //
    VirtualControlLoopNotification notification = new VirtualControlLoopNotification($event);
    notification.setNotification(ControlLoopNotificationType.OPERATION);
    notification.setMessage("Guard result for " + $operation.policy.getActor() + " " + $operation.policy.getRecipe()
        + " is " + $guardResponse.getResult());
    notification.setHistory($operation.getHistory());
    notification.setFrom("policy");
    notification.setPolicyName(drools.getRule().getName());
    notification.setPolicyScope("${policyScope}");
    notification.setPolicyVersion("${policyVersion}");
    
    PolicyEngine.manager.deliver("POLICY-CL-MGT", notification);
    
    if("Permit".equalsIgnoreCase($guardResponse.getResult())){
    
        modify($operation){setGuardApprovalStatus($guardResponse.getResult())};
    }
    else {
        //This is the Deny case
        $operation.startOperation($event);
        $operation.setOperationHasGuardDeny();
        retract($opTimer);
        retract($operation);
        modify($manager) {finishOperation($operation)};
    }
    
    retract($guardResponse);
            
end

/*
*
* This rule responds to APPC Response Events
*
* I would have like to be consistent and write the Response like this:
* $response : Response( CommonHeader.RequestId == $onset.getRequestId() )
*
* However, no compile error was given. But a runtime error was given. I think
* because drools is confused between the classname CommonHeader vs the property CommonHeader.
*
*/
rule "${policyName}.APPC.RESPONSE"
    when
        $params : Params( getClosedLoopControlName() == "${closedLoopControlName}" )
        $event : VirtualControlLoopEvent( closedLoopControlName == $params.getClosedLoopControlName(), 
            closedLoopEventStatus == ControlLoopEventStatus.ONSET ) 
        $manager : ControlLoopEventManager( closedLoopControlName == $event.getClosedLoopControlName(), 
            requestID == $event.getRequestId() )
        $operation : ControlLoopOperationManager( onset.closedLoopControlName == $event.getClosedLoopControlName(), 
            onset.getRequestId() == $event.getRequestId() )
        $opTimer : ControlLoopTimer( closedLoopControlName == $event.getClosedLoopControlName(), 
            requestID == $event.getRequestId().toString(), timerType == "Operation", !expired )
        $lock : TargetLock (requestID == $event.getRequestId())
        $response : Response( getCommonHeader().RequestId == $event.getRequestId() )
    then

    Logger logger = LoggerFactory.getLogger(drools.getRule().getPackage());
    logger.info("{}: {}", $params.getClosedLoopControlName(), drools.getRule().getName());
    logger.debug("{}: {}: event={} manager={} operation={} lock={} opTimer={} response={}", 
                 $params.getClosedLoopControlName(), drools.getRule().getName(),
                 $event, $manager, $operation, $lock, $opTimer, $response);
    //
    // Get the result of the operation
    //
    PolicyResult policyResult = $operation.onResponse($response);
    if (policyResult != null) {
        logger.debug("{}: {}: operation finished - result={}", 
                    $params.getClosedLoopControlName(), drools.getRule().getName(),
                    policyResult);
        //
        // This Operation has completed, construct a notification showing our results. (DB write - end operation)
        //
        VirtualControlLoopNotification notification = new VirtualControlLoopNotification($event);
        notification.setFrom("policy");
        notification.setPolicyName(drools.getRule().getName());
        notification.setPolicyScope("${policyScope}");
        notification.setPolicyVersion("${policyVersion}");
        notification.setMessage($operation.getOperationHistory());
        notification.setHistory($operation.getHistory());
        if (policyResult.equals(PolicyResult.SUCCESS)) {
            notification.setNotification(ControlLoopNotificationType.OPERATION_SUCCESS);
            //
            // Let interested parties know
            //
            PolicyEngine.manager.deliver("POLICY-CL-MGT", notification);
        } else {
            notification.setNotification(ControlLoopNotificationType.OPERATION_FAILURE);
            //
            // Let interested parties know
            //
            PolicyEngine.manager.deliver("POLICY-CL-MGT", notification);
        }
        //
        // Ensure the operation is complete
        //
        if ($operation.isOperationComplete() == true) {
            //
            // It is complete, remove it from memory
            //
            retract($operation);
            //
            // We must also retract the timer object
            // NOTE: We could write a Rule to do this
            //
            retract($opTimer);
            //
            // Complete the operation
            //
            modify($manager) {finishOperation($operation)};
        } else {
            //
            // Just doing this will kick off the LOCKED rule again
            //
            modify($operation) {};
        }
    } else {
        //
        // Its not finished yet (i.e. expecting more Response objects)
        //
        // Or possibly it is a leftover response that we timed the request out previously
        //
    }
    //
    // We are going to retract these objects from memory
    //
    retract($response);
end

/*
*
* The problem with Responses is that they don't have a controlLoopControlName
* field in them, so the only way to attach them is via RequestId. If we have multiple
* control loop .drl's loaded in the same container, we need to be sure the cleanup
* rules don't remove Responses for other control loops.
*
*/
rule "${policyName}.APPC.RESPONSE.CLEANUP"
    when
        $params : Params( getClosedLoopControlName() == "${closedLoopControlName}" )
        $response : Response($id : getCommonHeader().RequestId )
        not ( VirtualControlLoopEvent( requestId == $id, closedLoopEventStatus == ControlLoopEventStatus.ONSET ) ) 
    then

    Logger logger = LoggerFactory.getLogger(drools.getRule().getPackage());
    logger.info("{}: {}", $params.getClosedLoopControlName(), drools.getRule().getName());
    logger.debug("{}: {}: orphan appc response={}", 
                $params.getClosedLoopControlName(), drools.getRule().getName(), $id);
        
    //
    // Retract it
    //
    retract($response);
end

/*
*
* This rule responds to APPC Response Events using the new LCM interface provided by appc
*
*/
rule "${policyName}.APPC.LCM.RESPONSE"
    when
        $params : Params( getClosedLoopControlName() == "${closedLoopControlName}" )
        $event : VirtualControlLoopEvent( closedLoopControlName == $params.getClosedLoopControlName(), 
            closedLoopEventStatus == ControlLoopEventStatus.ONSET ) 
        $manager : ControlLoopEventManager( closedLoopControlName == $event.getClosedLoopControlName(), 
            requestID == $event.getRequestId() )
        $operation : ControlLoopOperationManager( onset.closedLoopControlName == $event.getClosedLoopControlName(), 
            onset.getRequestId() == $event.getRequestId() )
        $opTimer : ControlLoopTimer( closedLoopControlName == $event.getClosedLoopControlName(), 
            requestID == $event.getRequestId().toString(), timerType == "Operation", !expired )
        $lock : TargetLock (requestID == $event.getRequestId())
        $response : LcmResponseWrapper( getBody().getCommonHeader().getRequestId() == $event.getRequestId() )
    then

    Logger logger = LoggerFactory.getLogger(drools.getRule().getPackage());
    logger.info("{}: {}", $params.getClosedLoopControlName(), drools.getRule().getName());
    logger.debug("{}: {}: event={} manager={} operation={} lock={} opTimer={} response={}", 
                $params.getClosedLoopControlName(), drools.getRule().getName(),
                $event, $manager, $operation, $lock, $operation, $opTimer, $response);
    
    //
    // Get the result of the operation
    //
    PolicyResult policyResult = $operation.onResponse($response);
    if (policyResult != null) {
      logger.debug("{}: {}: operation finished - result={}", 
                  $params.getClosedLoopControlName(), drools.getRule().getName(),
                  policyResult);
      
      //
      // This Operation has completed, construct a notification showing our results. (DB write - end operation)
      //
      VirtualControlLoopNotification notification = new VirtualControlLoopNotification($event);
      notification.setFrom("policy");
      notification.setPolicyName(drools.getRule().getName());
      notification.setPolicyScope("${policyScope}");
      notification.setPolicyVersion("${policyVersion}");
      notification.setMessage($operation.getOperationHistory());
      notification.setHistory($operation.getHistory());
      if (policyResult.equals(PolicyResult.SUCCESS)) {
          notification.setNotification(ControlLoopNotificationType.OPERATION_SUCCESS);
      } else {
          notification.setNotification(ControlLoopNotificationType.OPERATION_FAILURE);
      }
      PolicyEngine.manager.deliver("POLICY-CL-MGT", notification);
      //
      // Ensure the operation is complete
      //
      if ($operation.isOperationComplete() == true) {
          //
          // It is complete, remove it from memory
          //
          retract($operation);
          //
          // We must also retract the timer object
          // NOTE: We could write a Rule to do this
          //
          retract($opTimer);
          //
          // Complete the operation
          //
          modify($manager) {finishOperation($operation)};
      } else {
          //
          // Just doing this will kick off the LOCKED rule again
          //
          modify($operation) {};
      }
    } else {
        //
        // Its not finished yet (i.e. expecting more Response objects)
        //
        // Or possibly it is a leftover response that we timed the request out previously
        //
    }
    //
    // We are going to retract these objects from memory
    //
    retract($response);
end

/*
*
* Clean Up any lingering LCM reponses
*
*/
rule "${policyName}.APPC.LCM.RESPONSE.CLEANUP"
    when
        $params : Params( getClosedLoopControlName() == "${closedLoopControlName}" )
        $response : LcmResponseWrapper($id : getBody().getCommonHeader().getRequestId )
        not ( VirtualControlLoopEvent( requestId == $id, closedLoopEventStatus == ControlLoopEventStatus.ONSET ) ) 
    then
    
    Logger logger = LoggerFactory.getLogger(drools.getRule().getPackage());
    logger.info("{}: {}", $params.getClosedLoopControlName(), drools.getRule().getName());
    logger.debug("{}: {}: orphan appc response={}", 
                $params.getClosedLoopControlName(), drools.getRule().getName(), $id);
    //
    // Retract it
    //
    retract($response);
end

/*
*
* This rule responds to SDNR Response Events using the new interface provided by SDNR
*
*/
rule "${policyName}.SDNR.RESPONSE"
    when
        $params : Params( getClosedLoopControlName() == "${closedLoopControlName}" )
        $event : VirtualControlLoopEvent( closedLoopControlName == $params.getClosedLoopControlName(), 
            closedLoopEventStatus == ControlLoopEventStatus.ONSET ) 
        $manager : ControlLoopEventManager( closedLoopControlName == $event.getClosedLoopControlName(), 
            requestID == $event.getRequestId() )
        $operation : ControlLoopOperationManager( onset.closedLoopControlName == $event.getClosedLoopControlName(), 
            onset.getRequestId() == $event.getRequestId() )
        $opTimer : ControlLoopTimer( closedLoopControlName == $event.getClosedLoopControlName(), 
            requestID == $event.getRequestId().toString(), timerType == "Operation", !expired )
        $lock : TargetLock (requestID == $event.getRequestId())
        $response : PciResponseWrapper( getBody().getCommonHeader().getRequestId() == $event.getRequestId() )
    then

    Logger logger = LoggerFactory.getLogger(drools.getRule().getPackage());
    logger.info("{}: {}", $params.getClosedLoopControlName(), drools.getRule().getName());
    logger.debug("{}: {}: event={} manager={} operation={} lock={} opTimer={} response={}", 
                $params.getClosedLoopControlName(), drools.getRule().getName(),
                $event, $manager, $operation, $lock, $operation, $opTimer, $response);
    
    //
    // Get the result of the operation
    //
    PolicyResult policyResult = $operation.onResponse($response);
    if (policyResult != null) {
      logger.debug("{}: {}: operation finished - result={}", 
                  $params.getClosedLoopControlName(), drools.getRule().getName(),
                  policyResult);
      
      //
      // This Operation has completed, construct a notification showing our results. (DB write - end operation)
      //
      VirtualControlLoopNotification notification = new VirtualControlLoopNotification($event);
      notification.setFrom("policy");
      notification.setPolicyName(drools.getRule().getName());
      notification.setPolicyScope("${policyScope}");
      notification.setPolicyVersion("${policyVersion}");
      notification.setMessage($operation.getOperationHistory());
      notification.setHistory($operation.getHistory());
      if (policyResult.equals(PolicyResult.SUCCESS)) {
          notification.setNotification(ControlLoopNotificationType.OPERATION_SUCCESS);
      } else {
          notification.setNotification(ControlLoopNotificationType.OPERATION_FAILURE);
      }
      PolicyEngine.manager.deliver("POLICY-CL-MGT", notification);
      //
      // Ensure the operation is complete
      //
      if ($operation.isOperationComplete()) {
          //
          // It is complete, remove it from memory
          //
          retract($operation);
          //
          // We must also retract the timer object
          // NOTE: We could write a Rule to do this
          //
          retract($opTimer);
          //
          // Complete the operation
          //
          modify($manager) {finishOperation($operation)};
      } else {
          //
          // Just doing this will kick off the LOCKED rule again
          //
          modify($operation) {};
      }
    } else {
        //
        // Its not finished yet (i.e. expecting more Response objects)
        //
        // Or possibly it is a leftover response that we timed the request out previously
        //
    }
    //
    // We are going to retract these objects from memory
    //
    retract($response);
end

/*
*
* Clean Up any lingering SDNR reponses
*
*/
rule "${policyName}.SDNR.RESPONSE.CLEANUP"
    when
        $params : Params( getClosedLoopControlName() == "${closedLoopControlName}" )
        $response : PciResponseWrapper($id : getBody().getCommonHeader().getRequestId )
        not ( VirtualControlLoopEvent( requestId == $id, closedLoopEventStatus == ControlLoopEventStatus.ONSET ) ) 
    then
    
    Logger logger = LoggerFactory.getLogger(drools.getRule().getPackage());
    logger.info("{}: {}", $params.getClosedLoopControlName(), drools.getRule().getName());
    logger.debug("{}: {}: orphan SDNR response={}", 
                $params.getClosedLoopControlName(), drools.getRule().getName(), $id);
    //
    // Retract it
    //
    retract($response);
end

/*
*
* This rule responds to SO Response Events
*
*/
rule "${policyName}.SO.RESPONSE"
    when
        $params : Params( getClosedLoopControlName() == "${closedLoopControlName}" )
        $event : VirtualControlLoopEvent( closedLoopControlName == $params.getClosedLoopControlName(), 
            closedLoopEventStatus == ControlLoopEventStatus.ONSET )
        $manager : ControlLoopEventManager( closedLoopControlName == $event.getClosedLoopControlName(), 
            requestID == $event.getRequestId() )
        $operation : ControlLoopOperationManager( onset.closedLoopControlName == $event.getClosedLoopControlName(), 
            onset.getRequestId() == $event.getRequestId() )
        $opTimer : ControlLoopTimer( closedLoopControlName == $event.getClosedLoopControlName(), 
            requestID == $event.getRequestId().toString(), timerType == "Operation", !expired )
        $lock : TargetLock (requestID == $event.getRequestId())
        $response : SOResponseWrapper(requestID.toString() == $event.getRequestId().toString() )
    then

    Logger logger = LoggerFactory.getLogger(drools.getRule().getPackage());
    logger.info("{}: {}", $params.getClosedLoopControlName(), drools.getRule().getName());
    logger.debug("{}: {}: event={} manager={} operation={} lock={} opTimer={} response={}", 
                $params.getClosedLoopControlName(), drools.getRule().getName(),
                $event, $manager, $operation, $lock, $operation, $opTimer, $response);
        
    // Get the result of the operation
    //
    PolicyResult policyResult = $operation.onResponse($response);
    if (policyResult != null) {
        logger.debug("{}: {}: operation finished - result={}", 
                    $params.getClosedLoopControlName(), drools.getRule().getName(),
                    policyResult);
      
        //
        // This Operation has completed, construct a notification showing our results
        //
        VirtualControlLoopNotification notification = new VirtualControlLoopNotification($event);
        notification.setFrom("policy");
        notification.setPolicyName(drools.getRule().getName());
        notification.setPolicyScope("${policyScope}");
        notification.setPolicyVersion("${policyVersion}");
        notification.setMessage($operation.getOperationHistory());
        notification.setHistory($operation.getHistory());
        if (policyResult.equals(PolicyResult.SUCCESS)) {
            notification.setNotification(ControlLoopNotificationType.OPERATION_SUCCESS);
        } else {
            notification.setNotification(ControlLoopNotificationType.OPERATION_FAILURE);

        }
        PolicyEngine.manager.deliver("POLICY-CL-MGT", notification);
        //
        // Ensure the operation is complete
        //
        if ($operation.isOperationComplete() == true) {
            //
            // It is complete, remove it from memory
            //
            retract($operation);
            //
            // We must also retract the timer object
            // NOTE: We could write a Rule to do this
            //
            retract($opTimer);
            //
            // Complete the operation
            //
            modify($manager) {finishOperation($operation)};
        } else {
            //
            // Just doing this will kick off the LOCKED rule again
            //
            modify($operation) {};
        }
    } else {
        //
        // Its not finished yet (i.e. expecting more Response objects)
        //
        // Or possibly it is a leftover response that we timed the request out previously
        //
    }
    //
    // We are going to retract these objects from memory
    //
    retract($response);

end

/*
*
* This rule responds to VFC Response Events
*
*/
rule "${policyName}.VFC.RESPONSE"
    when
        $params : Params( getClosedLoopControlName() == "${closedLoopControlName}" )
        $event : VirtualControlLoopEvent( closedLoopControlName == $params.getClosedLoopControlName(), 
            closedLoopEventStatus == ControlLoopEventStatus.ONSET )
        $manager : ControlLoopEventManager( closedLoopControlName == $event.getClosedLoopControlName(), 
            requestID == $event.getRequestId() )
        $operation : ControlLoopOperationManager( onset.closedLoopControlName == $event.getClosedLoopControlName(), 
            onset.getRequestId() == $event.getRequestId() )
        $opTimer : ControlLoopTimer( closedLoopControlName == $event.getClosedLoopControlName(), 
            requestID == $event.getRequestId().toString(), timerType == "Operation", !expired )
        $lock : TargetLock (requestID == $event.getRequestId())
        $response : VFCResponse( requestId.toString() == $event.getRequestId().toString() )    
    then
        Logger logger = LoggerFactory.getLogger(drools.getRule().getPackage());
        logger.info("{}: {}", $params.getClosedLoopControlName(), drools.getRule().getName());
        logger.debug("{}: {}: event={} manager={} operation={} lock={} opTimer={} response={}", 
                    $params.getClosedLoopControlName(), drools.getRule().getName(),
                    $event, $manager, $operation, $lock, $operation, $opTimer, $response);

        // Get the result of the operation
        //
        PolicyResult policyResult = $operation.onResponse($response);
        if (policyResult != null) {
            //
            // This Operation has completed, construct a notification showing our results
            //
            VirtualControlLoopNotification notification = new VirtualControlLoopNotification($event);
            notification.setFrom("policy");
            notification.setPolicyName(drools.getRule().getName());
            notification.setPolicyScope("${policyScope}");
            notification.setPolicyVersion("${policyVersion}");
            notification.setMessage($operation.getOperationHistory());
            notification.setHistory($operation.getHistory());
            //
            // Ensure the operation is complete
            //
            if ($operation.isOperationComplete() == true) {
                //
                // It is complete, remove it from memory
                //
                retract($operation);
                //
                // We must also retract the timer object
                // NOTE: We could write a Rule to do this
                //
                retract($opTimer);
                //
                // Complete the operation
                //
                modify($manager) {finishOperation($operation)};
            } else {
                //
                // Just doing this will kick off the LOCKED rule again
                //
                modify($operation) {};
            }
        } else {
            //
            // Its not finished yet (i.e. expecting more Response objects)
            //
            // Or possibly it is a leftover response that we timed the request out previously
            //
        }
        //
        // We are going to retract these objects from memory
        //
        retract($response);

end

/*
*
* This rule responds to SDNC Response Events
*
*/

rule "${policyName}.SDNC.RESPONSE"
    when
        $params : Params( getClosedLoopControlName() == "${closedLoopControlName}" )
        $event : VirtualControlLoopEvent( closedLoopControlName == $params.getClosedLoopControlName(), 
            closedLoopEventStatus == ControlLoopEventStatus.ONSET )
        $manager : ControlLoopEventManager( closedLoopControlName == $event.getClosedLoopControlName(), 
            requestID == $event.getRequestId() )
        $operation : ControlLoopOperationManager( onset.closedLoopControlName == $event.getClosedLoopControlName(), 
            onset.getRequestId() == $event.getRequestId() )
        $opTimer : ControlLoopTimer( closedLoopControlName == $event.getClosedLoopControlName(), 
            requestID == $event.getRequestId().toString(), timerType == "Operation", !expired )
        $lock : TargetLock (requestID == $event.getRequestId())
        $response : SdncResponse( requestId.toString() == $event.getRequestId().toString() )    
    then
        Logger logger = LoggerFactory.getLogger(drools.getRule().getPackage());
        logger.info("{}: {}", $params.getClosedLoopControlName(), drools.getRule().getName());
        logger.debug("{}: {}: event={} manager={} operation={} lock={} opTimer={} response={}", 
                    $params.getClosedLoopControlName(), drools.getRule().getName(),
                    $event, $manager, $operation, $lock, $operation, $opTimer, $response);

        // Get the result of the operation
        //
        PolicyResult policyResult = $operation.onResponse($response);
        if (policyResult != null) {
            //
            // This Operation has completed, construct a notification showing our results
            //
            VirtualControlLoopNotification notification = new VirtualControlLoopNotification($event);
            notification.setFrom("policy");
            notification.setPolicyName(drools.getRule().getName());
            notification.setPolicyScope("${policyScope}");
            notification.setPolicyVersion("${policyVersion}");
            notification.setMessage($operation.getOperationHistory());
            notification.setHistory($operation.getHistory());
            //
            // Ensure the operation is complete
            //
            if ($operation.isOperationComplete()) {
                //
                // It is complete, remove it from memory
                //
                retract($operation);
                //
                // We must also retract the timer object
                // NOTE: We could write a Rule to do this
                //
                retract($opTimer);
                //
                // Complete the operation
                //
                modify($manager) {finishOperation($operation)};
            } else {
                //
                // Just doing this will kick off the LOCKED rule again
                //
                modify($operation) {};
            }
        } else {
            //
            // Its not finished yet (i.e. expecting more Response objects)
            //
            // Or possibly it is a leftover response that we timed the request out previously
            //
        }
        //
        // We are going to retract these objects from memory
        //
        retract($response);

end

/*
*
* This manages a single timer.
* Due to a bug in the drools code, the drools timer needed to be split from most of the objects in the when clause
*
*/
rule "${policyName}.TIMER.FIRED"
    timer (expr: $timeout)
    when
        $timer : ControlLoopTimer($timeout : delay, !expired)
    then
        Logger logger = LoggerFactory.getLogger(drools.getRule().getPackage());
        logger.info("This is ${policyName}.TIMER.FIRED");
        modify($timer){setExpired(true)};
    end

/*
*
* This is the timer that manages the timeout for an individual operation.
*
*/
rule "${policyName}.EVENT.MANAGER.OPERATION.TIMEOUT"
    when
        $params : Params( getClosedLoopControlName() == "${closedLoopControlName}" )
        $event : VirtualControlLoopEvent( closedLoopControlName == $params.getClosedLoopControlName() )
        $manager : ControlLoopEventManager( closedLoopControlName == $event.getClosedLoopControlName(), 
            requestID == $event.getRequestId() )
        $operation : ControlLoopOperationManager( onset.closedLoopControlName == $event.getClosedLoopControlName(), 
            onset.getRequestId() == $event.getRequestId() )
        $opTimer : ControlLoopTimer( closedLoopControlName == $event.getClosedLoopControlName(), 
            requestID == $event.getRequestId().toString(), expired, timerType == "Operation" )
        $lock : TargetLock (requestID == $event.getRequestId())
    then
    
    Logger logger = LoggerFactory.getLogger(drools.getRule().getPackage());
    logger.info("{}: {}", $params.getClosedLoopControlName(), drools.getRule().getName());
    logger.debug("{}: {}: event={} manager={} operation={} lock={} opTimer={}", 
                $params.getClosedLoopControlName(), drools.getRule().getName(),
                $event, $manager, $operation, $lock, $operation, $opTimer);
    
    //
    // Tell it its timed out
    //
    $operation.setOperationHasTimedOut();
    //
    // Create a notification for it ("DB Write - end operation")
    //
    VirtualControlLoopNotification notification = new VirtualControlLoopNotification($event);
    notification.setFrom("policy");
    notification.setPolicyName(drools.getRule().getName());
    notification.setPolicyScope("${policyScope}");
    notification.setPolicyVersion("${policyVersion}");
    notification.setNotification(ControlLoopNotificationType.OPERATION_FAILURE);
    notification.setMessage($operation.getOperationHistory());
    notification.setHistory($operation.getHistory());
    //
    // Let interested parties know
    //
    PolicyEngine.manager.deliver("POLICY-CL-MGT", notification);
    //
    // Get rid of the timer
    //
    retract($opTimer);
    //
    // Ensure the operation is complete
    //
    if ($operation.isOperationComplete() == true) {
        //
        // It is complete, remove it from memory
        //
        retract($operation);
        //
        // Complete the operation
        //
        modify($manager) {finishOperation($operation)};
    } else {
        //
        // Just doing this will kick off the LOCKED rule again
        //
        modify($operation) {};
    }
end

/*
*
* This is the timer that manages the overall control loop timeout.
*
*/
rule "${policyName}.EVENT.MANAGER.TIMEOUT"
    when
        $params : Params( getClosedLoopControlName() == "${closedLoopControlName}" )
        $event : VirtualControlLoopEvent( closedLoopControlName == $params.getClosedLoopControlName() )
        $manager : ControlLoopEventManager( closedLoopControlName == $event.getClosedLoopControlName(), 
            requestID == $event.getRequestId() )
        $clTimer : ControlLoopTimer( closedLoopControlName == $event.getClosedLoopControlName(), 
            requestID == $event.getRequestId().toString(), expired, timerType == "ClosedLoop" )
    then
    
    Logger logger = LoggerFactory.getLogger(drools.getRule().getPackage());
    logger.info("{}: {}", $params.getClosedLoopControlName(), drools.getRule().getName());

    logger.debug("{}: {}: event={}", 
              $params.getClosedLoopControlName(), drools.getRule().getName(),
              $event);
    //
    // Tell the Event Manager it has timed out
    //
    VirtualControlLoopNotification notification = $manager.setControlLoopTimedOut();
    if (notification != null) {
        notification.setFrom("policy");
        notification.setPolicyName(drools.getRule().getName());
        notification.setPolicyScope("${policyScope}");
        notification.setPolicyVersion("${policyVersion}");
        //
        // Let interested parties know
        //
        PolicyEngine.manager.deliver("POLICY-CL-MGT", notification);
    }
    //
    // Retract the event
    //
    retract($event);
end

/*
*
* This rule cleans up the manager and other objects after an event has
* been retracted.
*
*/
rule "${policyName}.EVENT.MANAGER.CLEANUP"
    when
        $manager : ControlLoopEventManager( $clName : getClosedLoopControlName(), $requestId : getRequestID() )
        $operations : LinkedList()
                        from collect( ControlLoopOperationManager( onset.closedLoopControlName == $clName, 
                            onset.getRequestId() == $requestId ) )
        $timers : LinkedList()
                        from collect( ControlLoopTimer( closedLoopControlName == $clName, 
                            requestID == $requestId.toString() ) )
        $locks : LinkedList()
                        from collect( TargetLock (requestID == $requestId) )
        not( VirtualControlLoopEvent( closedLoopControlName == $clName, requestId == $requestId ) )
    then
    
    Logger logger = LoggerFactory.getLogger(drools.getRule().getPackage());
    logger.info("{}: {}", $clName, drools.getRule().getName());

    logger.debug("{}: {}: manager={} timers={} operations={}", 
              $clName, drools.getRule().getName(),
              $manager, $timers.size(), $operations.size());
    
    //
    // Retract EVERYTHING
    //
    retract($manager);
    
    for(Object manager: $operations) {
        retract((ControlLoopOperationManager) manager);
    }
    for(Object timer: $timers) {
        retract((ControlLoopTimer) timer);
    }
    for(Object lock: $locks) {
        TargetLock tgt = (TargetLock) lock;
        //
        // Ensure we release the lock
        //
        PolicyGuard.unlockTarget(tgt);
        retract(tgt);
    }
end

/*
*
* This rule will clean up any rogue onsets where there is no 
* ControlLoopParams object corresponding to the onset event.
*
*/
rule "${policyName}.EVENT.CLEANUP"
    when
        $event : VirtualControlLoopEvent( $clName: closedLoopControlName )
        not ( Params( getClosedLoopControlName() == $clName) )
    then
 
    Logger logger = LoggerFactory.getLogger(drools.getRule().getPackage());
    logger.info("{}: {}", $clName, drools.getRule().getName());
    logger.debug("{}: {}: orphan onset event={}", 
                $clName, drools.getRule().getName(), $event);

    retract($event);
end

/*
* Indicates to the cleaner that this Params object is still active.
* This has a higher salience so that it is fired before processing any events.
*/
rule "${policyName}.PARAMS.ACTIVE"
    salience 4
    when
        $params: Params( getClosedLoopControlName() == "${closedLoopControlName}",
                            getControlLoopYaml() == "${controlLoopYaml}" )
        ParamsCleaner( !identified, $active: active )
    then
 
    Logger logger = LoggerFactory.getLogger(drools.getRule().getPackage());
    logger.info("{}: {} : YAML=[{}]", $params.getClosedLoopControlName(), drools.getRule().getName(),
        $params.getControlLoopYaml());
        
    $active.add($params);
    
    // do NOT update anything at this point
end

/*
* Finished identifying active Params objects.  Begin deleting inactive Params.
* This has a higher salience so that it is fired before processing any events.
*/
rule "${policyName}.PARAMS.IDENTIFIED"
    salience 3
    when
        $cleaner: ParamsCleaner( !identified )
    then
 
    Logger logger = LoggerFactory.getLogger(drools.getRule().getPackage());
    logger.info("{}: {}", $cleaner.getClosedLoopControlName(), drools.getRule().getName());
    
    $cleaner.setIdentified(true);
    update($cleaner);
end

/*
* Delete Params objects that have not been identified as being active.
* This has a higher salience so that it is fired before processing any events.
*/
rule "${policyName}.PARAMS.DELETE"
    salience 2
    when
        $params: Params( )
        ParamsCleaner( identified, !active.contains($params) )
    then
 
    Logger logger = LoggerFactory.getLogger(drools.getRule().getPackage());
    logger.info("{}: {} : YAML=[{}]", $params.getClosedLoopControlName(), drools.getRule().getName(),
        $params.getControlLoopYaml());
        
    retract($params);
    
    // do NOT update anything at this point
end

/*
* Finished deleting inactive Params objects, so remove the cleaner.
* This has a higher salience so that it is fired before processing any events.
*/
rule "${policyName}.PARAMS.CLEANED"
    salience 1
    when
        $cleaner: ParamsCleaner( identified )
    then
 
    Logger logger = LoggerFactory.getLogger(drools.getRule().getPackage());
    logger.info("{}: {}", $cleaner.getClosedLoopControlName(), drools.getRule().getName());
    
    retract($cleaner);
end
